<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"defyodd.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":5},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Leetcode  704. 二分查找 24.12.13梦开始的地方">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode(持续更新ing)">
<meta property="og:url" content="https://defyodd.github.io/leetcode.md/index.html">
<meta property="og:site_name" content="This is defy_odd&#39;s blog">
<meta property="og:description" content="Leetcode  704. 二分查找 24.12.13梦开始的地方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://defyodd.github.io/leetcode.md/142.png">
<meta property="article:published_time" content="2025-01-12T14:28:24.000Z">
<meta property="article:modified_time" content="2025-03-28T12:40:15.131Z">
<meta property="article:author" content="defy_odd">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg">

<link rel="canonical" href="https://defyodd.github.io/leetcode.md/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode(持续更新ing) | This is defy_odd's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">This is defy_odd's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人在有闲的时候，才最像一个人 —— 梁实秋</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">16</span></a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/defyodd" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://defyodd.github.io/leetcode.md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="defy_odd">
      <meta itemprop="description" content="宝剑锋从磨砺出，梅花香自苦寒来">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="This is defy_odd's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode(持续更新ing)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-12 22:28:24" itemprop="dateCreated datePublished" datetime="2025-01-12T22:28:24+08:00">2025-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-28 20:40:15" itemprop="dateModified" datetime="2025-03-28T20:40:15+08:00">2025-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Leetcode-704-二分查找-24-12-13"><a href="#Leetcode-704-二分查找-24-12-13" class="headerlink" title="Leetcode  704. 二分查找 24.12.13"></a>Leetcode  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a> 24.12.13</h1><h2 id="梦开始的地方"><a href="#梦开始的地方" class="headerlink" title="梦开始的地方"></a>梦开始的地方</h2><span id="more"></span>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right){</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[middle]&lt;target){</span><br><span class="line">                left=middle<span class="number">+1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle]&gt;target){</span><br><span class="line">                right=middle<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-27-移除元素-24-12-15"><a href="#Leetcode-27-移除元素-24-12-15" class="headerlink" title="Leetcode 27. 移除元素 24.12.15"></a>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a> 24.12.15</h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p>
<ul>
<li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>
<li>返回 <code>k</code>。</li>
</ul>
<p><strong>用户评测：</strong></p>
<p>评测机将使用以下代码测试您的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int val = ...; // 要移除的值</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的预期答案。</span><br><span class="line">                            // 它以不等于 val 的值排序。</span><br><span class="line"></span><br><span class="line">int k = removeElement(nums, val); // 调用你的实现</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">sort(nums, 0, k); // 排序 nums 的前 k 个元素</span><br><span class="line">for (int i = 0; i &lt; actualLength; i++) {</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h2 id="题解：-双指针"><a href="#题解：-双指针" class="headerlink" title="题解： 双指针"></a>题解： 双指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast=<span class="number">0</span>;fast&lt;nums.<span class="built_in">size</span>();fast++){</span><br><span class="line">            <span class="keyword">if</span> (nums[fast]!=val){</span><br><span class="line">                nums[slow++]=nums[fast];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-977-有序数组的平方-24-12-15"><a href="#Leetcode-977-有序数组的平方-24-12-15" class="headerlink" title="Leetcode 977. 有序数组的平方 24.12.15"></a>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a> 24.12.15</h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li>
</ul>
<h2 id="题解：双指针，注意初始化vector长度"><a href="#题解：双指针，注意初始化vector长度" class="headerlink" title="题解：双指针，注意初始化vector长度"></a>题解：双指针，注意初始化vector长度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> t=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;=j;){</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">abs</span>(nums[i]) &gt; <span class="built_in">abs</span>(nums[j]) ) {</span><br><span class="line">                res[t]=nums[i]*nums[i];</span><br><span class="line">                <span class="comment">//res.insert(res.begin(),nums[i]*nums[i]);</span></span><br><span class="line">                i++;t--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                res[t]=nums[j]*nums[j];</span><br><span class="line">                <span class="comment">//res.insert(res.begin(),nums[j]*nums[j]);</span></span><br><span class="line">                j--;t--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-209-长度最小的子数组-24-12-17"><a href="#Leetcode-209-长度最小的子数组-24-12-17" class="headerlink" title="Leetcode 209. 长度最小的子数组 24.12.17"></a>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a> 24.12.17</h1><h2 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p>
<p><strong>子数组</strong></p>
<p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<h2 id="题解：滑动窗口"><a href="#题解：滑动窗口" class="headerlink" title="题解：滑动窗口"></a>题解：滑动窗口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;<span class="comment">//起始</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">99999999</span>;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//j为终止下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++){</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target){</span><br><span class="line">                len=j-i<span class="number">+1</span>;</span><br><span class="line">                res=<span class="built_in">min</span>(res,len);</span><br><span class="line">                sum-=nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum&lt;target&amp;&amp;res==<span class="number">99999999</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-59-螺旋矩阵-II-24-12-17"><a href="#Leetcode-59-螺旋矩阵-II-24-12-17" class="headerlink" title="Leetcode 59. 螺旋矩阵 II  24.12.17"></a>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II </a> 24.12.17</h1><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
<h2 id="题解：模拟，注意创建二维数组方式"><a href="#题解：模拟，注意创建二维数组方式" class="headerlink" title="题解：模拟，注意创建二维数组方式"></a>题解：模拟，注意创建二维数组方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) {</span><br><span class="line">        <span class="comment">//采用左闭右开</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> startx=<span class="number">0</span>;<span class="type">int</span> starty=<span class="number">0</span>;<span class="comment">//起始位置</span></span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>;<span class="comment">//右开</span></span><br><span class="line">        <span class="type">int</span> t=n/<span class="number">2</span>;<span class="comment">//转几圈</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t){</span><br><span class="line">            <span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (j=starty;j&lt;n-offset;j++){</span><br><span class="line">                matrix[startx][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (i=startx;i&lt;n-offset;i++){</span><br><span class="line">                matrix[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">for</span> (;j&gt;starty;j--){</span><br><span class="line">                matrix[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">for</span> (;i&gt;startx;i--){</span><br><span class="line">                matrix[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            startx++;starty++;offset++;</span><br><span class="line">            t--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">1</span>){</span><br><span class="line">            matrix[n/<span class="number">2</span>][n/<span class="number">2</span>]=count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-203-移除链表元素"><a href="#Leetcode-203-移除链表元素" class="headerlink" title="Leetcode 203. 移除链表元素"></a>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><h2 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<h2 id="题解：虚拟头节点"><a href="#题解：虚拟头节点" class="headerlink" title="题解：虚拟头节点"></a>题解：虚拟头节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//方法一：虚拟头节点，这种方法比较正常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListNode* dhead= <span class="keyword">new</span> ListNode;</span><br><span class="line">        dhead-&gt;next=head;</span><br><span class="line">        ListNode* cur=dhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val==val){</span><br><span class="line">                cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dhead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：不创建虚拟头节点，直接使用第一个元素作为head，需要多处理一下删除头节点的情况，相对复杂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="literal">NULL</span>&amp;&amp;head-&gt;val==val){</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">if</span> (cur==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>&amp;&amp;cur!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val==val){</span><br><span class="line">                cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-707-设计链表-1-12"><a href="#Leetcode-707-设计链表-1-12" class="headerlink" title="Leetcode 707. 设计链表 1.12"></a>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 </a>1.12</h1><h2 id="题面-5"><a href="#题面-5" class="headerlink" title="题面"></a>题面</h2><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]</span><br><span class="line">[[], [1], [3], [1, 2], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, 2, null, 3]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = new MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(1);</span><br><span class="line">myLinkedList.addAtTail(3);</span><br><span class="line">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 2</span><br><span class="line">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= index, val &lt;= 1000</code></li>
<li>请不要使用内置的 LinkedList 库。</li>
<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>
</ul>
<h2 id="题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head-gt-next开始"><a href="#题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head-gt-next开始" class="headerlink" title="题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head->next开始"></a>题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head-&gt;next开始</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目当中的ListNode的结构是这样的</span></span><br><span class="line"><span class="comment">// struct ListNode{</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     ListNode *next;</span></span><br><span class="line"><span class="comment">// };</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() {</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        head-&gt;val=<span class="number">0</span>;</span><br><span class="line">        head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 第一个元素的下标是0，从虚拟头节点的下一个开始向后遍历</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index--){</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListNode *t=<span class="keyword">new</span> ListNode;</span><br><span class="line">        t-&gt;val=val;</span><br><span class="line">        t-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next=t;    </span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            cur= cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;next=t;</span><br><span class="line">        t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        t-&gt;val=val;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index&gt;size) <span class="keyword">return</span> ;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="comment">//index-=1;</span></span><br><span class="line">        <span class="keyword">while</span> (index&gt;<span class="number">0</span>){</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        }</span><br><span class="line">        t-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=t;</span><br><span class="line">        t-&gt;val=val;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        ListNode *cur=head;</span><br><span class="line">        <span class="comment">//index-=1;</span></span><br><span class="line">        <span class="keyword">while</span> (index&gt;<span class="number">0</span>){</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        size--;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-206-反转链表-1-13"><a href="#Leetcode-206-反转链表-1-13" class="headerlink" title="Leetcode 206. 反转链表 1.13"></a>Leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 </a>1.13</h1><h2 id="题面-6"><a href="#题面-6" class="headerlink" title="题面"></a>题面</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h2 id="题解-双指针解法-就是一个cur一个pre，让cur往前指。"><a href="#题解-双指针解法-就是一个cur一个pre，让cur往前指。" class="headerlink" title="题解 双指针解法 就是一个cur一个pre，让cur往前指。"></a>题解 双指针解法 就是一个cur一个pre，让cur往前指。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *cur=head;</span><br><span class="line">        ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur){</span><br><span class="line">            ListNode *t=cur-&gt;next;</span><br><span class="line">            cur-&gt;next= pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=t;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="解法二：递归，其实就是简略版本的双指针"><a href="#解法二：递归，其实就是简略版本的双指针" class="headerlink" title="解法二：递归，其实就是简略版本的双指针"></a>解法二：递归，其实就是简略版本的双指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *pre,ListNode *cur)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (cur==<span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    ListNode *t= cur-&gt;next;</span><br><span class="line">    cur-&gt;next=pre;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverse</span>(cur,t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>,head);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-24-两两交换链表中的节点-1-14"><a href="#leetcode-24-两两交换链表中的节点-1-14" class="headerlink" title="leetcode 24. 两两交换链表中的节点 1.14"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 </a>1.14</h1><h2 id="题面-7"><a href="#题面-7" class="headerlink" title="题面"></a>题面</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur-gt-next-NULL-amp-amp-cur-gt-next-gt-next-NULL。两者要一起，最后return的是dummyhead-gt-next。"><a href="#题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur-gt-next-NULL-amp-amp-cur-gt-next-gt-next-NULL。两者要一起，最后return的是dummyhead-gt-next。" class="headerlink" title="题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur->next!=NULL&&cur->next->next!=NULL。两者要一起，最后return的是dummyhead->next。"></a>题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;next!=NULL。两者要一起，最后return的是dummyhead-&gt;next。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            ListNode *t = cur-&gt;next;</span><br><span class="line">            ListNode *t1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = t;</span><br><span class="line">            t-&gt;next = t1;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-19-删除链表的倒数第-N-个结点-1-18"><a href="#leetcode-19-删除链表的倒数第-N-个结点-1-18" class="headerlink" title="leetcode 19. 删除链表的倒数第 N 个结点 1.18"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a> 1.18</h1><h2 id="题面-8"><a href="#题面-8" class="headerlink" title="题面"></a>题面</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h2 id="题解：经典双指针（fast-slow）-dummyhead-先移动fast指针，到相距n-1的位置，之后再同时移动fast和slow"><a href="#题解：经典双指针（fast-slow）-dummyhead-先移动fast指针，到相距n-1的位置，之后再同时移动fast和slow" class="headerlink" title="题解：经典双指针（fast,slow）+dummyhead,先移动fast指针，到相距n+1的位置，之后再同时移动fast和slow"></a>题解：经典双指针（fast,slow）+dummyhead,先移动fast指针，到相距n+1的位置，之后再同时移动fast和slow</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        dummyhead-&gt;next=head;</span><br><span class="line">        ListNode *fast = dummyhead;</span><br><span class="line">        ListNode *slow = dummyhead;</span><br><span class="line">        <span class="comment">//注意fast要再往前移一位，先移动fast指针，之后再移动slow指针</span></span><br><span class="line">        <span class="comment">//这样刚好slow指针可以移动到需要被删除的节点的前一个</span></span><br><span class="line">        n++; </span><br><span class="line">        <span class="keyword">while</span> (n--&amp;&amp;fast!=<span class="literal">NULL</span>){</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">NULL</span>){</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode142-环形链表-II-1-19"><a href="#leetcode142-环形链表-II-1-19" class="headerlink" title="leetcode142. 环形链表 II 1.19"></a>leetcode<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a> 1.19</h1><h2 id="题面-9"><a href="#题面-9" class="headerlink" title="题面"></a>题面</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<h2 id="思路：karl-is-all-you-need"><a href="#思路：karl-is-all-you-need" class="headerlink" title="思路：karl is all you need."></a>思路：karl is all you need.</h2><h2 id="双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。"><a href="#双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。" class="headerlink" title="双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。"></a>双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。</h2><img src="/leetcode.md/142.png" class="" title="img">
<p>假设快指针走两格，慢指针走一格。</p>
<p>在A点相遇时，快指针已经走过了<script type="math/tex">x+y+n(y+z)</script>的路程</p>
<p>慢指针走过了<script type="math/tex">x+y</script>的路程。至于为什么不需要加上<script type="math/tex">k(z+y)</script>，主要是因为，只要慢指针进入之后，快指针一定只需要一圈之内就能追上，因为速度是慢指针的两倍。</p>
<p><strong>相遇是判断是否有环的重要判断条件</strong>。</p>
<p>然后就开始了快乐的公式推导过程：</p>
<p>因为我们假设的是快指针是慢指针速度的两倍，所以</p>
<script type="math/tex; mode=display">
2(x+y) = x+y+n(y+z)</script><p>因为我们想要得到的是<script type="math/tex">x</script> ,所以</p>
<script type="math/tex; mode=display">
x = n(y+z)-y</script><p><strong>接下来一步很关键，很厉害</strong></p>
<script type="math/tex; mode=display">
x = (n-1)(y+z)+z</script><p>这说明，在<script type="math/tex">n=1</script>的时候，<script type="math/tex">x=z</script>。如果<script type="math/tex">n>1</script>的时候，只不过是快指针在环里面多走了<script type="math/tex">n-1</script>圈。和最后相遇是没有差别的。</p>
<p><strong>其实，<script type="math/tex">x=z</script>的意义在于，我从起点向进入环的点走和从相遇点到进入点的距离是一样的。这个是重要的寻找进入点的条件。就在相遇之后，利用这个条件，让两个点都向进入点走。两个相遇的时候就是进入点</strong>.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow){</span><br><span class="line">                ListNode *index1 = fast;</span><br><span class="line">                ListNode *index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1!=index2){</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode242-有效的字母异位词-1-20"><a href="#leetcode242-有效的字母异位词-1-20" class="headerlink" title="leetcode242. 有效的字母异位词 1.20"></a>leetcode<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a> 1.20</h1><h2 id="题面-10"><a href="#题面-10" class="headerlink" title="题面"></a>题面</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "anagram", t = "nagaram"</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "rat", t = "car"</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>
<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul>
<p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h2 id="题解：之前上课的时候遇到过这样的题目"><a href="#题解：之前上课的时候遇到过这样的题目" class="headerlink" title="题解：之前上课的时候遇到过这样的题目"></a>题解：之前上课的时候遇到过这样的题目</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="type">int</span> arr [<span class="number">26</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++){</span><br><span class="line">            arr[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;t.<span class="built_in">size</span>();i++){</span><br><span class="line">            arr[t[i]-<span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span> (arr[i]!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode349-两个数组的交集-1-20"><a href="#leetcode349-两个数组的交集-1-20" class="headerlink" title="leetcode349. 两个数组的交集 1.20"></a>leetcode<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 </a>1.20</h1><h2 id="题面-11"><a href="#题面-11" class="headerlink" title="题面"></a>题面</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的</em> <em>交集</em></p>
<p>输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
<h2 id="题解：使用unordered-set进行操作，并且注意将vector转化成set时候的代码。使用-find函数时，没找到会返回-end-。"><a href="#题解：使用unordered-set进行操作，并且注意将vector转化成set时候的代码。使用-find函数时，没找到会返回-end-。" class="headerlink" title="题解：使用unordered_set进行操作，并且注意将vector转化成set时候的代码。使用.find函数时，没找到会返回.end()。"></a>题解：使用unordered_set进行操作，并且注意将vector转化成set时候的代码。使用.find函数时，没找到会返回.end()。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">num_set</span><span class="params">(nums<span class="number">1.</span>begin(),nums<span class="number">1.</span>end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums<span class="number">2.</span><span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">if</span> (num_set.<span class="built_in">find</span>(nums2[i])!=num_set.<span class="built_in">end</span>()){</span><br><span class="line">                res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0349.两个数组的交集.html#思路">代码随想录</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29931565/article/details/124511606">【C++】unordered_set中find()用法及代码示例_c++ unorderset的find-CSDN博客</a></p>
<h1 id="leetcode-1-两数之和-1-21"><a href="#leetcode-1-两数之和-1-21" class="headerlink" title="leetcode 1. 两数之和 1.21"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a> 1.21</h1><h2 id="这是很多人梦开始的地方（不是很能理解这道题是容易题）"><a href="#这是很多人梦开始的地方（不是很能理解这道题是容易题）" class="headerlink" title="这是很多人梦开始的地方（不是很能理解这道题是容易题）"></a>这是很多人梦开始的地方（不是很能理解这道题是容易题）</h2><h2 id="题面-12"><a href="#题面-12" class="headerlink" title="题面"></a>题面</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<h2 id="题解：重点是使用unordered-map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums-i-得到。"><a href="#题解：重点是使用unordered-map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums-i-得到。" class="headerlink" title="题解：重点是使用unordered_map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums[i]得到。"></a>题解：重点是使用unordered_map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums[i]得到。</h2><h3 id="1、双重循环深似海，皆为纸上谈兵之事"><a href="#1、双重循环深似海，皆为纸上谈兵之事" class="headerlink" title="1、双重循环深似海，皆为纸上谈兵之事"></a>1、双重循环深似海，皆为纸上谈兵之事</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;nums.<span class="built_in">size</span>();j++){</span><br><span class="line">                <span class="keyword">if</span> (nums[i]+nums[j]==target){</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="2、一招map走天下，全是Carl下人间"><a href="#2、一招map走天下，全是Carl下人间" class="headerlink" title="2、一招map走天下，全是Carl下人间"></a>2、一招map走天下，全是Carl下人间</h3><h3 id="梦开始的地方，Leetcode：1-两数之和，学透哈希表，map使用有技巧！-哔哩哔哩-bilibili"><a href="#梦开始的地方，Leetcode：1-两数之和，学透哈希表，map使用有技巧！-哔哩哔哩-bilibili" class="headerlink" title="梦开始的地方，Leetcode：1.两数之和，学透哈希表，map使用有技巧！_哔哩哔哩_bilibili"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aT41177mK/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=db8b493990184e57185c5ce1734577f2">梦开始的地方，Leetcode：1.两数之和，学透哈希表，map使用有技巧！_哔哩哔哩_bilibili</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="type">int</span> s = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(s);</span><br><span class="line">            <span class="keyword">if</span> (it!=map.<span class="built_in">end</span>()){</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            }</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）"><a href="#3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）" class="headerlink" title="3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）"></a>3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> val = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">find</span>(val) == map.<span class="built_in">end</span>()) {</span><br><span class="line">                map[nums[i]] = i;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> {map[val], i};</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ULTRAmanTAROACE/article/details/137115610">C++之STL整理（3）之map 用法（创建、赋值、方法）整理_c++ map初始化-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_48508278/article/details/118531197">C++中 Map的了解与基本用法（代码演示+自我总结+map中一对多的用法）_c++map函数的用法-CSDN博客</a></p>
<h1 id="leetcode-454-四数相加-II-1-22"><a href="#leetcode-454-四数相加-II-1-22" class="headerlink" title="leetcode 454. 四数相加 II 1.22"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a> 1.22</h1><h2 id="题面-属于第一眼看会懵逼系列"><a href="#题面-属于第一眼看会懵逼系列" class="headerlink" title="题面 属于第一眼看会懵逼系列"></a>题面 属于第一眼看会懵逼系列</h2><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p> <strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length</code></li>
<li><code>n == nums2.length</code></li>
<li><code>n == nums3.length</code></li>
<li><code>n == nums4.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li>
</ul>
<h2 id="题解：思路类似于242题，把前两个当作是一个整体，把a-b的出现的次数放进一个map中，然后遍历c和d，计算-c-d-，查找这个值是否在map中出现过"><a href="#题解：思路类似于242题，把前两个当作是一个整体，把a-b的出现的次数放进一个map中，然后遍历c和d，计算-c-d-，查找这个值是否在map中出现过" class="headerlink" title="题解：思路类似于242题，把前两个当作是一个整体，把a+b的出现的次数放进一个map中，然后遍历c和d，计算-(c+d)，查找这个值是否在map中出现过"></a>题解：思路类似于242题，把前两个当作是一个整体，把a+b的出现的次数放进一个map中，然后遍历c和d，计算-(c+d)，查找这个值是否在map中出现过</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;nums1.size() ;i++){</span></span><br><span class="line">        <span class="comment">//     for (int j=0;j&lt;nums2.size();j++){</span></span><br><span class="line">        <span class="comment">//         map[nums1[i]+nums2[j]]++;//在map中存放前两个数组的a+b以及出现的次数，用于后续计数</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a:nums1){<span class="comment">//遍历vector可以这么干</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b: nums2){</span><br><span class="line">                map[a+b]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;nums3.size();i++){</span></span><br><span class="line">        <span class="comment">//     for (int j=0;j&lt;nums4.size();j++){</span></span><br><span class="line">        <span class="comment">//         int t = -(nums3[i]+nums4[j]);</span></span><br><span class="line">        <span class="comment">//         if (map.find(t)!=map.end()){</span></span><br><span class="line">        <span class="comment">//             count+=map[t];</span></span><br><span class="line">        <span class="comment">//         }</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c:nums3){</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d:nums4){</span><br><span class="line">                <span class="type">int</span> t = -(c+d);</span><br><span class="line">                <span class="keyword">if</span> (map.<span class="built_in">find</span>(t)!=map.<span class="built_in">end</span>()){</span><br><span class="line">                    count+=map[t];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-15-三数之和-1-25"><a href="#leetcode-15-三数之和-1-25" class="headerlink" title="leetcode 15. 三数之和 1.25"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a> 1.25</h1><h2 id="该不会还是不会（即使看了三遍的Carl……"><a href="#该不会还是不会（即使看了三遍的Carl……" class="headerlink" title="该不会还是不会（即使看了三遍的Carl……)"></a>该不会还是不会（即使看了三遍的Carl……)</h2><h2 id="果然是梦破碎的地方-第一次看了三遍视频还没看明白的题目"><a href="#果然是梦破碎的地方-第一次看了三遍视频还没看明白的题目" class="headerlink" title="果然是梦破碎的地方 第一次看了三遍视频还没看明白的题目"></a>果然是梦破碎的地方 第一次看了三遍视频还没看明白的题目</h2><h2 id="题面-13"><a href="#题面-13" class="headerlink" title="题面"></a>题面</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="题解：双指针-乱七八糟的去重"><a href="#题解：双指针-乱七八糟的去重" class="headerlink" title="题解：双指针+乱七八糟的去重"></a>题解：双指针+乱七八糟的去重</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="comment">//a b c 三个数，i就是a，left是b，right是c</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每一次遍历，会把包含a的所有集合都扫描一遍了</span></span><br><span class="line">            <span class="comment">//换句话说，nums[i]是这个组合中最小的数，如果这个最小的数大于0了，三数相加就根本不可能是0了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对a去重,这里判断的是跟前一个元素，而不是后一个。</span></span><br><span class="line">            <span class="comment">//因为如果跟后一个进行判断的话，left在a的后一个，如果刚好一样的话，等于是说元组之间不能重复，不符合题意</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i<span class="number">+1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//因为已经排好序了，left比i大一点，right是最大的</span></span><br><span class="line">            <span class="keyword">while</span> (right&gt;left){</span><br><span class="line">                <span class="keyword">if</span> (nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[i],nums[left],nums[right]});</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">//b,c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[left]==nums[left<span class="number">+1</span>]) left++;</span><br><span class="line">					</span><br><span class="line">                    <span class="comment">//这里是得到一个组合之后再进行两个指针的收缩，开始的时候搞成了每一次循环都做一次操作</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43547900/article/details/121972917">c++:vector sort()排序-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0015.三数之和.html#思路">代码随想录</a></p>
<h1 id="leetcode18-四数之和-1-26"><a href="#leetcode18-四数之和-1-26" class="headerlink" title="leetcode18. 四数之和 1.26"></a>leetcode<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a> 1.26</h1><h2 id="这题逆天完了"><a href="#这题逆天完了" class="headerlink" title="这题逆天完了"></a>这题逆天完了</h2><h2 id="题面-14"><a href="#题面-14" class="headerlink" title="题面"></a>题面</h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<h2 id="题解：最快的一版答案，重点在剪枝去重-我XXX-，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了"><a href="#题解：最快的一版答案，重点在剪枝去重-我XXX-，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了" class="headerlink" title="题解：最快的一版答案，重点在剪枝去重(我XXX)，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了"></a>题解：最快的一版答案，重点在剪枝去重(我XXX)，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) {</span><br><span class="line">        <span class="comment">//思路类似于三数之和,在外面再套一个for循环代表第四个数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();<span class="comment">//不用这一步也行，一样的</span></span><br><span class="line">        <span class="keyword">if</span> (len&lt;<span class="number">4</span>) <span class="keyword">return</span> res;<span class="comment">//这个一定要，被一个[0]干傻了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-3</span>;i++){</span><br><span class="line">            <span class="comment">//可以理解为这是第一个指针</span></span><br><span class="line">            <span class="comment">//先做一步剪枝,这里要注意，nums[i]和target都要是正数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里的两个剪枝的话，效果一般，可加可不加</span></span><br><span class="line">            <span class="comment">//if(nums[i]&gt;target&amp;&amp;nums[i]&gt;0&amp;&amp;target&gt;=0) return res;</span></span><br><span class="line">            <span class="comment">//if (nums[i]&gt;target/4) return res;</span></span><br><span class="line">             <span class="comment">//对i去重</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来开始快乐的三数之和的部分咯</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;len<span class="number">-2</span>;j++){</span><br><span class="line">                <span class="comment">//j是三数之和中的i，也就是第二个数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//剪枝，这个Carl的二级剪枝没啥效果</span></span><br><span class="line">                <span class="comment">//if (nums[j]+nums[i]&gt;target&amp;&amp;target&gt;=0&amp;&amp;nums[i]+nums[j]&gt;0) break;</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//这个剪枝是看leetcode里面题解看到的，感觉很合理，而且确实剪枝了一部分</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j]+nums[i]&gt;target/<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">if</span> (j&gt;i<span class="number">+1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> left = j<span class="number">+1</span>;</span><br><span class="line">                <span class="type">int</span> right = len<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (left&lt;right){</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right]&gt;target) right--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right]&lt;target) left++;</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">//放入结果</span></span><br><span class="line">                        res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[i],nums[j],nums[left],nums[right]});</span><br><span class="line">                        <span class="comment">//对left和right去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[left]==nums[left<span class="number">+1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//移动left和right</span></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CFY1226/article/details/131386022">Char 34: runtime error: addition of unsigned offset to 0x603000000070 overflowed to 0x60300000006c-CSDN博客</a></p>
<h1 id="leetcode-344-反转字符串-1-27"><a href="#leetcode-344-反转字符串-1-27" class="headerlink" title="leetcode 344. 反转字符串 1.27"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a> 1.27</h1><h2 id="似乎是最简单的一集"><a href="#似乎是最简单的一集" class="headerlink" title="似乎是最简单的一集"></a>似乎是最简单的一集</h2><h2 id="题面-15"><a href="#题面-15" class="headerlink" title="题面"></a>题面</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须<strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = ["h","e","l","l","o"]</span><br><span class="line">输出：["o","l","l","e","h"]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = ["H","a","n","n","a","h"]</span><br><span class="line">输出：["h","a","n","n","a","H"]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 都是 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符\</li>
</ul>
<h2 id="题解：来，四种"><a href="#题解：来，四种" class="headerlink" title="题解：来，四种"></a>题解：来，四种</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一：没想到swap</span></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;s.size()/2;i++){</span></span><br><span class="line">        <span class="comment">//     // char t = s[i];</span></span><br><span class="line">        <span class="comment">//     // s[i] = s[s.size()-i-1];</span></span><br><span class="line">        <span class="comment">//     // s[s.size()-i-1] = t;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二：题解是个好东西，swap：你好</span></span><br><span class="line">        <span class="comment">//     swap(s[i],s[s.size()-i-1]);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三：评论区是个好东西,reverse：你好</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四：看了Carl的视频之后，感觉双指针更清晰一点（虽然原理上差不多）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;i++,j--){</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-541-反转字符串-II-1-27"><a href="#leetcode-541-反转字符串-II-1-27" class="headerlink" title="leetcode 541. 反转字符串 II 1.27"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a> 1.27</h1><h2 id="问就是不会……"><a href="#问就是不会……" class="headerlink" title="问就是不会……"></a>问就是不会……</h2><h2 id="题面-16"><a href="#题面-16" class="headerlink" title="题面"></a>题面</h2><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "abcdefg", k = 2</span><br><span class="line">输出："bacdfeg"</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "abcd", k = 2</span><br><span class="line">输出："bacd"</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由小写英文组成</li>
<li><code>1 &lt;= k &lt;= 104</code></li>
</ul>
<h2 id="题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数"><a href="#题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数" class="headerlink" title="题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数"></a>题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="comment">//i+=2k是直接跳到2K处，可以减少运算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i+=<span class="number">2</span>*k){</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这个是为了反转前k个字符的判断条件，针对每一个i，不论是否满足2k，只要满足有k个就反转。</span></span><br><span class="line">            <span class="comment">//小于等于s.size()是针对于最后一部分的判断。注意这里有等号</span></span><br><span class="line">            <span class="keyword">if</span> (i+k&lt;=s.<span class="built_in">size</span>()){</span><br><span class="line">                <span class="comment">//reverse函数可以这样用，从第i位开始s.begin()+i。</span></span><br><span class="line">                <span class="comment">//而且reverse函数实现的时候是左闭右开的，第二个参数直接加上就行了</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">begin</span>()+i+k);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">end</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">};</span><br><span class="line"><span class="comment">//方法二，手写reverse函数，注意这里要用&amp;引用，这样才能保证操作的是同一个string。亲测，没加上没用。并且使用双指针，比只有一个变量方便多了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=start,j=end;i&lt;j;i++,j--){</span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i+=<span class="number">2</span>*k){</span><br><span class="line">            <span class="keyword">if</span> (i+k&lt;=s.<span class="built_in">size</span>()){</span><br><span class="line">                <span class="comment">//由于是自己定义的，这里的end就需要-1.</span></span><br><span class="line">                <span class="built_in">reverse</span>(s,i,i+k<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">reverse</span>(s,i,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0541.反转字符串II.html#思路">代码随想录</a></p>
<h1 id="leetcode151-151-反转字符串中的单词-25-3-7"><a href="#leetcode151-151-反转字符串中的单词-25-3-7" class="headerlink" title="leetcode151 151. 反转字符串中的单词 25.3.7"></a>leetcode151 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a> 25.3.7</h1><h2 id="孩子我回来啦-一整个2月份在焦虑和自我内耗中度过……"><a href="#孩子我回来啦-一整个2月份在焦虑和自我内耗中度过……" class="headerlink" title="孩子我回来啦 一整个2月份在焦虑和自我内耗中度过……"></a>孩子我回来啦 一整个2月份在焦虑和自我内耗中度过……</h2><h2 id="题面-17"><a href="#题面-17" class="headerlink" title="题面"></a>题面</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "the sky is blue"</span><br><span class="line">输出："blue is sky the"</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "  hello world  "</span><br><span class="line">输出："world hello"</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "a good   example"</span><br><span class="line">输出："example good a"</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li>
<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>
</ul>
<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>
<h2 id="题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了"><a href="#题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了" class="headerlink" title="题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了"></a>题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//反转单个单词</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start,j=end;i&lt;j;i++,j--){</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除多余空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removespace</span><span class="params">(string &amp;s)</span></span>{</span><br><span class="line">        <span class="type">int</span> fastindex=<span class="number">0</span>,slowindex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//去除开头的空格</span></span><br><span class="line">        <span class="keyword">while</span> (s[fastindex]==<span class="string">' '</span>&amp;&amp;fastindex&lt;s.<span class="built_in">size</span>()) fastindex++;</span><br><span class="line">        <span class="comment">//去除中间的空格，但是保证单词中间还有一个空格</span></span><br><span class="line">        <span class="keyword">for</span> (;fastindex&lt;s.<span class="built_in">size</span>();fastindex++){</span><br><span class="line">            <span class="keyword">if</span> (fastindex<span class="number">-1</span>&gt;<span class="number">0</span> <span class="comment">//这个是保证下面两个条件的一个前提</span></span><br><span class="line">            &amp;&amp;s[fastindex] == s[fastindex<span class="number">-1</span>] </span><br><span class="line">            &amp;&amp;s[fastindex]==<span class="string">' '</span> </span><br><span class="line">            <span class="comment">//需要我忽略的是中间有两个空格的时候。换句话说就是当遇到中间有两个空格的时候</span></span><br><span class="line">            <span class="comment">//不移动slowindex指针，让后面的字符来覆盖前面的空格</span></span><br><span class="line">            ) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> s[slowindex++] = s[fastindex];</span><br><span class="line">            <span class="comment">//这个操作会把最后末尾的空格也加进来,如果末尾还有空格的话</span></span><br><span class="line">            <span class="comment">//会刚好再多读入一个空格，如果没有的话就不会</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//去除末尾空格,如果有空格的话，</span></span><br><span class="line">        <span class="comment">// while (s[slowindex]==' ' &amp;&amp;slowindex&gt;0) slowindex--;</span></span><br><span class="line">        <span class="comment">// s.resize(slowindex);</span></span><br><span class="line">        <span class="keyword">if</span> (s[slowindex<span class="number">-1</span>]==<span class="string">' '</span>) <span class="comment">//这里是判断字符串的最后一位是不是空格</span></span><br><span class="line">            s.<span class="built_in">resize</span>(slowindex<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">resize</span>(slowindex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="built_in">removespace</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> entry = <span class="literal">false</span>; <span class="comment">//这个是判断是否进入字符串，反转每个单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">if</span> ((!entry)||(s[i<span class="number">-1</span>]==<span class="string">' '</span>&amp;&amp;s[i]!=<span class="string">' '</span>)){</span><br><span class="line">                begin = i;</span><br><span class="line">                entry = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (entry &amp;&amp; s[i]==<span class="string">' '</span>&amp;&amp; s[i<span class="number">-1</span>]!=<span class="string">' '</span>){ <span class="comment">//这里如果用i+1来判断的话有可能溢出</span></span><br><span class="line">                end = i<span class="number">-1</span>;</span><br><span class="line">                entry = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">reverse</span>(s,begin,end);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (entry &amp;&amp; (i==s.<span class="built_in">size</span>()<span class="number">-1</span>) &amp;&amp; s[i]!=<span class="string">' '</span>){ <span class="comment">//这是判断最后一个单词，后面没有空格了</span></span><br><span class="line">                end = i;</span><br><span class="line">                entry = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">reverse</span>(s,begin,end);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-455-455-分发饼干-25-3-8"><a href="#leetcode-455-455-分发饼干-25-3-8" class="headerlink" title="leetcode 455 455. 分发饼干 25.3.8"></a>leetcode 455 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a> 25.3.8</h1><p>想学贪心和dp了</p>
<h2 id="题面-18"><a href="#题面-18" class="headerlink" title="题面"></a>题面</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。</span><br><span class="line">所以你应该输出 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出 2。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= g.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li>
</ul>
<h2 id="题解：先排个序，从小到大看饼干能满足哪些小孩"><a href="#题解：先排个序，从小到大看饼干能满足哪些小孩" class="headerlink" title="题解：先排个序，从小到大看饼干能满足哪些小孩"></a>题解：先排个序，从小到大看饼干能满足哪些小孩</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">if</span> (index&lt;g.<span class="built_in">size</span>() &amp;&amp; g[index]&lt;=s[i]){</span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-376-376-摆动序列-25-3-10"><a href="#leetcode-376-376-摆动序列-25-3-10" class="headerlink" title="leetcode 376 376. 摆动序列 25.3.10"></a>leetcode 376 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a> 25.3.10</h1><p>昨天有点摆了</p>
<h2 id="题面-19"><a href="#题面-19" class="headerlink" title="题面"></a>题面</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>
<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这个序列包含几个长度为 7 摆动序列。</span><br><span class="line">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p>
<h2 id="题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。"><a href="#题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。" class="headerlink" title="题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。"></a>题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">//当前的差值</span></span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">//之前的插值</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>; <span class="comment">//假设最后有一个峰值，默认为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++){</span><br><span class="line">            cur = nums[i<span class="number">+1</span>] - nums[i];</span><br><span class="line">            <span class="comment">//这里的判断条件，pre可以等于0是为了满足有不单调但中间有平坡的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((cur&gt;<span class="number">0</span>&amp;&amp;pre&lt;=<span class="number">0</span>)||(pre&gt;=<span class="number">0</span>&amp;&amp;cur&lt;<span class="number">0</span>)){</span><br><span class="line">                res++;</span><br><span class="line">                pre = cur;</span><br><span class="line">                <span class="comment">//pre放在这里赋值时为了解决单调有平坡的情况，pre不需要每次都跟着cur改变，只需要记录有变化的时候</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-53-53-最大子数组和-25-3-14"><a href="#leetcode-53-53-最大子数组和-25-3-14" class="headerlink" title="leetcode 53 53. 最大子数组和 25.3.14"></a>leetcode 53 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a> 25.3.14</h1><p>emmm刚搞完一个分享会，ppt做的好累</p>
<h2 id="题面-20"><a href="#题面-20" class="headerlink" title="题面"></a>题面</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h2 id="题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums-i-1-。不是在遇到负数就下一个。只要count还是-gt-0就还对下一个数有增大作用。是在count-lt-0才要跳过。"><a href="#题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums-i-1-。不是在遇到负数就下一个。只要count还是-gt-0就还对下一个数有增大作用。是在count-lt-0才要跳过。" class="headerlink" title="题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums[i+1]。不是在遇到负数就下一个。只要count还是>0就还对下一个数有增大作用。是在count<0才要跳过。"></a>题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums[i+1]。不是在遇到负数就下一个。只要count还是&gt;0就还对下一个数有增大作用。是在count&lt;0才要跳过。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-99999</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//记录每个区间的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (count&gt;res) res = count;</span><br><span class="line">            <span class="keyword">if</span> (count&lt;<span class="number">0</span>) count=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//不是遇到负数就直接跳过，而是整体为负数才跳过。</span></span><br><span class="line">            <span class="comment">//只要我这一部分的和还是正数，对于后面的数就是一个增大的作用，关心的主体是nums[i+1]</span></span><br><span class="line">            <span class="comment">//整体为负数会拖累后面累加的数，不会让总体的和更大，不如重新开始</span></span><br><span class="line">            <span class="comment">//而且每次都及时更新到res里面了，不用担心会丢下最大值</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-122-122-买卖股票的最佳时机-II-25-3-15"><a href="#leetcode-122-122-买卖股票的最佳时机-II-25-3-15" class="headerlink" title="leetcode 122 122. 买卖股票的最佳时机 II 25.3.15"></a>leetcode 122 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a> 25.3.15</h1><p>昨晚太晚睡了，今天一整天都没精神</p>
<h2 id="题面-21"><a href="#题面-21" class="headerlink" title="题面"></a>题面</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。</span><br><span class="line">最大总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">最大总利润为 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<h2 id="题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值"><a href="#题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值" class="headerlink" title="题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值"></a>题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里实际构建了一个新的数组，就是每天的利润</span></span><br><span class="line">        <span class="comment">// 我需要找到的是每天的利润都为正数的天数全加起来就可以了</span></span><br><span class="line">        <span class="comment">// 因为比如第一天买入，第三天卖出</span></span><br><span class="line">        <span class="comment">// prices[3]-prices[0] = prices[3]-prices[2]+prices[2]-prices[1]+prices[1]-prices[0]</span></span><br><span class="line">        <span class="comment">// 要保证利润最大，就是只需要每两个之间的差值为正数就是赚</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++){</span><br><span class="line">            res += <span class="built_in">max</span>((prices[i]-prices[i<span class="number">-1</span>]),<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-55-55-跳跃游戏-25-3-17"><a href="#leetcode-55-55-跳跃游戏-25-3-17" class="headerlink" title="leetcode 55 55. 跳跃游戏 25.3.17"></a>leetcode 55 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a> 25.3.17</h1><p>昨天周日，六刷thu</p>
<h2 id="题面-22"><a href="#题面-22" class="headerlink" title="题面"></a>题面</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）"><a href="#我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）" class="headerlink" title="我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）"></a>我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res,nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==<span class="number">0</span> &amp;&amp; res == i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="代码随想录版本，更加简洁，直接用了cover，然后还直接让i-lt-cover，直接就卡死了它的范围，就不会出现我自己写的那些问题"><a href="#代码随想录版本，更加简洁，直接用了cover，然后还直接让i-lt-cover，直接就卡死了它的范围，就不会出现我自己写的那些问题" class="headerlink" title="代码随想录版本，更加简洁，直接用了cover，然后还直接让i<=cover，直接就卡死了它的范围，就不会出现我自己写的那些问题"></a>代码随想录版本，更加简洁，直接用了cover，然后还直接让i&lt;=cover，直接就卡死了它的范围，就不会出现我自己写的那些问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> cover = nums[<span class="number">0</span>]; <span class="comment">//int cover = 0;等于0，等于nums[0]都可以</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=cover;i++){</span><br><span class="line">            cover = <span class="built_in">max</span>(cover,nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span> (cover&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-45-45-跳跃游戏-II-25-3-23"><a href="#leetcode-45-45-跳跃游戏-II-25-3-23" class="headerlink" title="leetcode 45 45. 跳跃游戏 II 25.3.23"></a>leetcode 45 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a> 25.3.23</h1><p>精彩的一周，没想到这周能发生让我如此印象深刻的一件事</p>
<h2 id="题面-23"><a href="#题面-23" class="headerlink" title="题面"></a>题面</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>题目保证可以到达 <code>nums[n-1]</code></li>
</ul>
<h2 id="题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums-size-1的话，就需要将ans-。"><a href="#题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums-size-1的话，就需要将ans-。" class="headerlink" title="题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums.size()-1的话，就需要将ans++。"></a>题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums.size()-1的话，就需要将ans++。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cover=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre_cover = <span class="number">0</span>; <span class="comment">//用来标记在第一次能到达的最远距离，然后再依据这个更新。这一部分是跳一次之内都能达到的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            cover = <span class="built_in">max</span>(i+nums[i],cover);</span><br><span class="line">            <span class="comment">//计算在这个能达到的最远区间中延伸出去所能达到的最远，最远的那里只需要跳一次就能到</span></span><br><span class="line">            <span class="keyword">if</span> (i==pre_cover){ </span><br><span class="line">            <span class="comment">//看第一次最远能到哪里，当已经遇到最远的地方的时候，它延伸出来的cover能有多少，之后再继续更新</span></span><br><span class="line">                <span class="keyword">if</span> (pre_cover&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>) {</span><br><span class="line">                    ans++;</span><br><span class="line">                    pre_cover=cover;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-274-274-H-指数-25-3-23"><a href="#leetcode-274-274-H-指数-25-3-23" class="headerlink" title="leetcode 274 274. H 指数 25.3.23"></a>leetcode 274 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/h-index/">274. H 指数</a> 25.3.23</h1><p>先看到的这题，然后才拿出的代码随想录</p>
<h2 id="题面-24"><a href="#题面-24" class="headerlink" title="题面"></a>题面</h2><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code> 指数</strong>。</p>
<p>根据维基百科上 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code> <strong>指数</strong> 是指他（她）至少发表了 <code>h</code> 篇论文，并且 <strong>至少</strong> 有 <code>h</code> 篇论文被引用次数大于等于 <code>h</code> 。如果 <code>h</code> 有多种可能的值，<strong><code>h</code> 指数</strong> 是其中最大的那个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：citations = [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：citations = [1,3,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == citations.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>
</ul>
<h2 id="题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i-1小了就是答案"><a href="#题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i-1小了就是答案" class="headerlink" title="题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i+1小了就是答案"></a>题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i+1小了就是答案</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(citations.<span class="built_in">begin</span>(),citations.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//直接倒叙排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;citations.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">if</span> (citations[i]&lt;i<span class="number">+1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> citations.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-LCR-134-Pow-x-n-25-3-28"><a href="#leetcode-LCR-134-Pow-x-n-25-3-28" class="headerlink" title="leetcode LCR 134. Pow(x, n) 25.3.28"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">LCR 134. Pow(x, n)</a> 25.3.28</h1><p>一开始直接 <script type="math/tex">pow(x,n)</script> 过了，结果一看要用快速幂，赶紧补了一下</p>
<h2 id="题面-25"><a href="#题面-25" class="headerlink" title="题面"></a>题面</h2><p>实现 <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>-100.0 &lt; x &lt; 100.0</code></li>
<li><code>-231 &lt;= n &lt;= 231-1</code></li>
<li><code>-104 &lt;= xn &lt;= 104</code></li>
</ul>
<h2 id="题解：直接放快速幂的吧"><a href="#题解：直接放快速幂的吧" class="headerlink" title="题解：直接放快速幂的吧"></a>题解：直接放快速幂的吧</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">1</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> num = n;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">0</span>){</span><br><span class="line">            num = - num;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (num){ <span class="comment">//重点是这几行</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp; <span class="number">1</span>) ans *=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="GPT老师对于代码的解析："><a href="#GPT老师对于代码的解析：" class="headerlink" title="GPT老师对于代码的解析："></a>GPT老师对于代码的解析：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(num){</span><br><span class="line">    <span class="keyword">if</span>(num &amp; <span class="number">1</span>) ans *= x;  <span class="comment">// 如果 num 的最低位是 1，则累乘 x</span></span><br><span class="line">    x *= x;                <span class="comment">// x 自乘，相当于 x^(2^i)</span></span><br><span class="line">    num &gt;&gt;= <span class="number">1</span>;             <span class="comment">// 右移 num，相当于 num //= 2</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="逐行分析："><a href="#逐行分析：" class="headerlink" title="逐行分析："></a>逐行分析：</h4><ol>
<li><strong><code>while(num)</code></strong><ul>
<li>只要 <code>num</code> 不为 <code>0</code>，就继续循环，即处理 <code>num</code> 的二进制表示的每一位。</li>
</ul>
</li>
<li><strong><code>if(num &amp; 1) ans \*= x;</code></strong><ul>
<li><code>num &amp; 1</code> 用于检查 <code>num</code> 的最低位是否为 <code>1</code>：<ul>
<li>如果 <code>num</code> 的最低位是 <code>1</code>，说明当前的 <code>x</code> 需要计入结果，因此将 <code>x</code> 乘入 <code>ans</code>。</li>
<li>例如：<code>3</code> 的二进制是 <code>11</code>，最低位 <code>1</code> 说明当前的 <code>x</code> 需要乘入 <code>ans</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>x *= x;</code></strong><ul>
<li><code>x</code> 进行平方，<code>x</code> 变成 <code>x^2</code>，然后 <code>x^4</code>，<code>x^8</code>，依次递增。</li>
<li>这样通过二进制的方式，可以用少量的乘法完成指数计算。</li>
</ul>
</li>
<li><strong><code>num &gt;&gt;= 1;</code></strong><ul>
<li><code>num</code> 右移一位，相当于 <code>num //= 2</code>，去掉最低位，继续处理下一位。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="例子分析："><a href="#例子分析：" class="headerlink" title="例子分析："></a>例子分析：</h3><p>计算 <script type="math/tex">3^{13}</script></p>
<h4 id="计算步骤："><a href="#计算步骤：" class="headerlink" title="计算步骤："></a>计算步骤：</h4><p><code>13</code> 的二进制是 <strong><code>1101</code></strong><br> 从右到左遍历，每一位表示是否需要乘入当前的 <code>x</code>（即 <code>3^(2^i)</code>）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>num (二进制)</th>
<th>x (当前幂)</th>
<th>ans（累乘结果）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1101 (13)</strong></td>
<td>3</td>
<td>3</td>
<td>最低位是 1，乘入 ans</td>
</tr>
<tr>
<td><strong>110 (6)</strong></td>
<td>9</td>
<td>3</td>
<td>最低位是 0，跳过</td>
</tr>
<tr>
<td><strong>11 (3)</strong></td>
<td>81</td>
<td>3 × 81 = 243</td>
<td>最低位是 1，乘入 ans</td>
</tr>
<tr>
<td><strong>1 (1)</strong></td>
<td>6561</td>
<td>243 × 6561 = 1594323</td>
<td>最低位是 1，乘入 ans</td>
</tr>
</tbody>
</table>
</div>
<p>最终 <code>ans = 1594323</code>，即 <script type="math/tex">3^{13}=15943233</script>.</p>
<h1 id="leetcode-134-加油站-25-3-28"><a href="#leetcode-134-加油站-25-3-28" class="headerlink" title="leetcode 134. 加油站 25.3.28"></a>leetcode <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">134. 加油站</a> 25.3.28</h1><p>贪心ing</p>
<h2 id="题面-26"><a href="#题面-26" class="headerlink" title="题面"></a>题面</h2><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>gas.length == n</code></li>
<li><code>cost.length == n</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li>
</ul>
<h2 id="题解：在每次遇到cursum-lt-0的时候，就证明说起点要从下一个开始"><a href="#题解：在每次遇到cursum-lt-0的时候，就证明说起点要从下一个开始" class="headerlink" title="题解：在每次遇到cursum<0的时候，就证明说起点要从下一个开始"></a>题解：在每次遇到cursum&lt;0的时候，就证明说起点要从下一个开始</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="type">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.<span class="built_in">size</span>();i++){</span><br><span class="line">            cursum += gas[i] - cost[i];</span><br><span class="line">            totalsum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (cursum&lt;<span class="number">0</span>){</span><br><span class="line">                start = i<span class="number">+1</span>;</span><br><span class="line">                cursum = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (totalsum&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"><i class="fa fa-tag"></i></a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/Mask-TS-and-ODC-SA-net.md/" rel="next" title="Mask-TS and ODC-SA net">
      Mask-TS and ODC-SA net <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-24-12-13"><span class="nav-number">1.</span> <span class="nav-text">Leetcode  704. 二分查找 24.12.13</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">1.1.</span> <span class="nav-text">梦开始的地方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2"><span class="nav-number">1.2.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3"><span class="nav-number">1.3.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-24-12-15"><span class="nav-number">2.</span> <span class="nav-text">Leetcode 27. 移除元素 24.12.15</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-1"><span class="nav-number">2.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.2.</span> <span class="nav-text">题解： 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-24-12-15"><span class="nav-number">3.</span> <span class="nav-text">Leetcode 977. 有序数组的平方 24.12.15</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-2"><span class="nav-number">3.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%88%9D%E5%A7%8B%E5%8C%96vector%E9%95%BF%E5%BA%A6"><span class="nav-number">3.2.</span> <span class="nav-text">题解：双指针，注意初始化vector长度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-24-12-17"><span class="nav-number">4.</span> <span class="nav-text">Leetcode 209. 长度最小的子数组 24.12.17</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-3"><span class="nav-number">4.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">4.2.</span> <span class="nav-text">题解：滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II-24-12-17"><span class="nav-number">5.</span> <span class="nav-text">Leetcode 59. 螺旋矩阵 II  24.12.17</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E6%A8%A1%E6%8B%9F%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">题解：模拟，注意创建二维数组方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">6.</span> <span class="nav-text">Leetcode 203. 移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-4"><span class="nav-number">6.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="nav-number">6.2.</span> <span class="nav-text">题解：虚拟头节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8-1-12"><span class="nav-number">7.</span> <span class="nav-text">Leetcode 707. 设计链表 1.12</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-5"><span class="nav-number">7.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E6%8C%BA%E7%BA%A2%E7%9A%84%EF%BC%8C%E8%BF%99%E7%BB%99%E4%B8%80%E4%B8%AA%E6%A0%B7%E4%BE%8B%E6%94%B9%E4%B8%80%E6%AC%A1bug%EF%BC%8C%E6%94%B9%E4%BA%86%E6%9C%89%E5%8D%8A%E5%B0%8F%E6%97%B6%E8%BF%98%E4%B8%8D%E6%AD%A2%EF%BC%8C%E5%85%B3%E6%B3%A8addAtTail%EF%BC%8CaddAtIndex%EF%BC%8CdeleteAtIndex%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%83%E4%BB%AC%E9%83%BD%E4%BB%8Ehead%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86%EF%BC%8C%E4%B8%8D%E4%BB%8Ehead-gt-next%E5%BC%80%E5%A7%8B"><span class="nav-number">7.2.</span> <span class="nav-text">题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head-&gt;next开始</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-1-13"><span class="nav-number">8.</span> <span class="nav-text">Leetcode 206. 反转链表 1.13</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-6"><span class="nav-number">8.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95-%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AAcur%E4%B8%80%E4%B8%AApre%EF%BC%8C%E8%AE%A9cur%E5%BE%80%E5%89%8D%E6%8C%87%E3%80%82"><span class="nav-number">8.2.</span> <span class="nav-text">题解 双指针解法 就是一个cur一个pre，让cur往前指。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%92%E5%BD%92%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E7%AE%80%E7%95%A5%E7%89%88%E6%9C%AC%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">8.3.</span> <span class="nav-text">解法二：递归，其实就是简略版本的双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-1-14"><span class="nav-number">9.</span> <span class="nav-text">leetcode 24. 两两交换链表中的节点 1.14</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-7"><span class="nav-number">9.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%98%AF%E8%8A%82%E7%82%B9%EF%BC%8C%E9%9C%80%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9%EF%BC%8C%E8%AE%A9cur%E6%8C%87%E9%92%88%E5%8E%BB%E6%93%8D%E4%BD%9C%E5%90%8E%E9%9D%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%BE%AA%E7%8E%AF%E6%9D%A1%E4%BB%B6%E6%98%AF%E8%A6%81cur-gt-next-NULL-amp-amp-cur-gt-next-gt-next-NULL%E3%80%82%E4%B8%A4%E8%80%85%E8%A6%81%E4%B8%80%E8%B5%B7%EF%BC%8C%E6%9C%80%E5%90%8Ereturn%E7%9A%84%E6%98%AFdummyhead-gt-next%E3%80%82"><span class="nav-number">9.2.</span> <span class="nav-text">题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur-&gt;next!&#x3D;NULL&amp;&amp;cur-&gt;next-&gt;next!&#x3D;NULL。两者要一起，最后return的是dummyhead-&gt;next。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9-1-18"><span class="nav-number">10.</span> <span class="nav-text">leetcode 19. 删除链表的倒数第 N 个结点 1.18</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-8"><span class="nav-number">10.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88fast-slow%EF%BC%89-dummyhead-%E5%85%88%E7%A7%BB%E5%8A%A8fast%E6%8C%87%E9%92%88%EF%BC%8C%E5%88%B0%E7%9B%B8%E8%B7%9Dn-1%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%86%8D%E5%90%8C%E6%97%B6%E7%A7%BB%E5%8A%A8fast%E5%92%8Cslow"><span class="nav-number">10.2.</span> <span class="nav-text">题解：经典双指针（fast,slow）+dummyhead,先移动fast指针，到相距n+1的位置，之后再同时移动fast和slow</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II-1-19"><span class="nav-number">11.</span> <span class="nav-text">leetcode142. 环形链表 II 1.19</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-9"><span class="nav-number">11.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9Akarl-is-all-you-need"><span class="nav-number">11.2.</span> <span class="nav-text">思路：karl is all you need.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%B5%B0%E7%9A%84%E5%BF%AB%E4%B8%80%E4%B8%AA%E8%B5%B0%E7%9A%84%E6%85%A2%EF%BC%8C%E5%BF%AB%E7%9A%84%E4%B8%80%E6%AC%A1%E8%B5%B0%E4%B8%A4%E6%A0%BC%EF%BC%8C%E6%85%A2%E7%9A%84%E4%B8%80%E6%AC%A1%E8%B5%B0%E4%B8%80%E6%A0%BC%E3%80%82%E5%A6%82%E6%9E%9C%E6%9C%89%E7%8E%AF%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%9C%A8%E7%8E%AF%E5%86%85%E7%9B%B8%E9%81%87%E3%80%82%E7%A1%AE%E5%AE%9A%E8%BF%9B%E5%85%A5%E7%8E%AF%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E3%80%82"><span class="nav-number">11.3.</span> <span class="nav-text">双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">11.4.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-1-20"><span class="nav-number">12.</span> <span class="nav-text">leetcode242. 有效的字母异位词 1.20</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-10"><span class="nav-number">12.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E4%B9%8B%E5%89%8D%E4%B8%8A%E8%AF%BE%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E8%BF%87%E8%BF%99%E6%A0%B7%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="nav-number">12.2.</span> <span class="nav-text">题解：之前上课的时候遇到过这样的题目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-1-20"><span class="nav-number">13.</span> <span class="nav-text">leetcode349. 两个数组的交集 1.20</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-11"><span class="nav-number">13.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E4%BD%BF%E7%94%A8unordered-set%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%B3%A8%E6%84%8F%E5%B0%86vector%E8%BD%AC%E5%8C%96%E6%88%90set%E6%97%B6%E5%80%99%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E4%BD%BF%E7%94%A8-find%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E6%B2%A1%E6%89%BE%E5%88%B0%E4%BC%9A%E8%BF%94%E5%9B%9E-end-%E3%80%82"><span class="nav-number">13.2.</span> <span class="nav-text">题解：使用unordered_set进行操作，并且注意将vector转化成set时候的代码。使用.find函数时，没找到会返回.end()。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">13.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-1-21"><span class="nav-number">14.</span> <span class="nav-text">leetcode 1. 两数之和 1.21</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%99%E6%98%AF%E5%BE%88%E5%A4%9A%E4%BA%BA%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%88%E4%B8%8D%E6%98%AF%E5%BE%88%E8%83%BD%E7%90%86%E8%A7%A3%E8%BF%99%E9%81%93%E9%A2%98%E6%98%AF%E5%AE%B9%E6%98%93%E9%A2%98%EF%BC%89"><span class="nav-number">14.1.</span> <span class="nav-text">这是很多人梦开始的地方（不是很能理解这道题是容易题）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-12"><span class="nav-number">14.2.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E9%87%8D%E7%82%B9%E6%98%AF%E4%BD%BF%E7%94%A8unordered-map%E5%8E%BB%E5%AD%98%E5%8F%96%E9%82%A3%E4%BA%9B%E5%B7%B2%E7%BB%8F%E9%81%8D%E5%8E%86%E8%BF%87%E7%9A%84%E6%95%B0%E3%80%82%E5%9B%A0%E4%B8%BA%E5%8F%AA%E8%A6%81%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%8C%E9%81%8D%E5%8E%86%E8%BF%87%E7%9A%84%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%9C%A8map%E9%87%8C%E9%9D%A2%EF%BC%8C%E8%80%8C%E4%B8%94%E5%B7%A7%E5%A6%99%E7%9A%84%E6%98%AF%EF%BC%8C%E7%94%B1%E4%BA%8E%E5%8F%AA%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E7%94%B1target-nums-i-%E5%BE%97%E5%88%B0%E3%80%82"><span class="nav-number">14.3.</span> <span class="nav-text">题解：重点是使用unordered_map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums[i]得到。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%8F%8C%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%B7%B1%E4%BC%BC%E6%B5%B7%EF%BC%8C%E7%9A%86%E4%B8%BA%E7%BA%B8%E4%B8%8A%E8%B0%88%E5%85%B5%E4%B9%8B%E4%BA%8B"><span class="nav-number">14.3.1.</span> <span class="nav-text">1、双重循环深似海，皆为纸上谈兵之事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%B8%80%E6%8B%9Bmap%E8%B5%B0%E5%A4%A9%E4%B8%8B%EF%BC%8C%E5%85%A8%E6%98%AFCarl%E4%B8%8B%E4%BA%BA%E9%97%B4"><span class="nav-number">14.3.2.</span> <span class="nav-text">2、一招map走天下，全是Carl下人间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8CLeetcode%EF%BC%9A1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%8C%E5%AD%A6%E9%80%8F%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8Cmap%E4%BD%BF%E7%94%A8%E6%9C%89%E6%8A%80%E5%B7%A7%EF%BC%81-%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9-bilibili"><span class="nav-number">14.3.3.</span> <span class="nav-text">梦开始的地方，Leetcode：1.两数之和，学透哈希表，map使用有技巧！_哔哩哔哩_bilibili</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E4%BD%A0%E6%9C%89%E4%B8%80%E4%B8%AA%E8%83%BD%E8%B7%91%E5%B0%B1%E8%A1%8C%E3%80%82%E5%8F%AA%E4%B8%8D%E8%BF%87%E8%BF%99%E6%AC%A1%E6%98%AF%E4%BB%A3%E7%A0%81%E8%83%BD%E8%B7%91%EF%BC%88leetcode%E5%80%9F%E9%89%B4%E7%89%88%EF%BC%89"><span class="nav-number">14.3.4.</span> <span class="nav-text">3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-1"><span class="nav-number">14.4.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II-1-22"><span class="nav-number">15.</span> <span class="nav-text">leetcode 454. 四数相加 II 1.22</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-%E5%B1%9E%E4%BA%8E%E7%AC%AC%E4%B8%80%E7%9C%BC%E7%9C%8B%E4%BC%9A%E6%87%B5%E9%80%BC%E7%B3%BB%E5%88%97"><span class="nav-number">15.1.</span> <span class="nav-text">题面 属于第一眼看会懵逼系列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E6%80%9D%E8%B7%AF%E7%B1%BB%E4%BC%BC%E4%BA%8E242%E9%A2%98%EF%BC%8C%E6%8A%8A%E5%89%8D%E4%B8%A4%E4%B8%AA%E5%BD%93%E4%BD%9C%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B4%E4%BD%93%EF%BC%8C%E6%8A%8Aa-b%E7%9A%84%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%94%BE%E8%BF%9B%E4%B8%80%E4%B8%AAmap%E4%B8%AD%EF%BC%8C%E7%84%B6%E5%90%8E%E9%81%8D%E5%8E%86c%E5%92%8Cd%EF%BC%8C%E8%AE%A1%E7%AE%97-c-d-%EF%BC%8C%E6%9F%A5%E6%89%BE%E8%BF%99%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E5%9C%A8map%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%BF%87"><span class="nav-number">15.2.</span> <span class="nav-text">题解：思路类似于242题，把前两个当作是一个整体，把a+b的出现的次数放进一个map中，然后遍历c和d，计算-(c+d)，查找这个值是否在map中出现过</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-1-25"><span class="nav-number">16.</span> <span class="nav-text">leetcode 15. 三数之和 1.25</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A5%E4%B8%8D%E4%BC%9A%E8%BF%98%E6%98%AF%E4%B8%8D%E4%BC%9A%EF%BC%88%E5%8D%B3%E4%BD%BF%E7%9C%8B%E4%BA%86%E4%B8%89%E9%81%8D%E7%9A%84Carl%E2%80%A6%E2%80%A6"><span class="nav-number">16.1.</span> <span class="nav-text">该不会还是不会（即使看了三遍的Carl……)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9C%E7%84%B6%E6%98%AF%E6%A2%A6%E7%A0%B4%E7%A2%8E%E7%9A%84%E5%9C%B0%E6%96%B9-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9C%8B%E4%BA%86%E4%B8%89%E9%81%8D%E8%A7%86%E9%A2%91%E8%BF%98%E6%B2%A1%E7%9C%8B%E6%98%8E%E7%99%BD%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="nav-number">16.2.</span> <span class="nav-text">果然是梦破碎的地方 第一次看了三遍视频还没看明白的题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-13"><span class="nav-number">16.3.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88-%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="nav-number">16.4.</span> <span class="nav-text">题解：双指针+乱七八糟的去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-2"><span class="nav-number">16.5.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-1-26"><span class="nav-number">17.</span> <span class="nav-text">leetcode18. 四数之和 1.26</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%99%E9%A2%98%E9%80%86%E5%A4%A9%E5%AE%8C%E4%BA%86"><span class="nav-number">17.1.</span> <span class="nav-text">这题逆天完了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-14"><span class="nav-number">17.2.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E6%9C%80%E5%BF%AB%E7%9A%84%E4%B8%80%E7%89%88%E7%AD%94%E6%A1%88%EF%BC%8C%E9%87%8D%E7%82%B9%E5%9C%A8%E5%89%AA%E6%9E%9D%E5%8E%BB%E9%87%8D-%E6%88%91XXX-%EF%BC%8C%E7%AB%9F%E7%84%B6%E8%BF%98%E5%8D%A1%E6%88%91%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E5%92%8Clong%E9%9D%A0%E3%80%82%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%89%AA%E6%9E%9D%E7%94%A8return%EF%BC%8C%E4%BD%86%E6%98%AF%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%AA%E8%83%BD%E6%98%AFbreak%EF%BC%8C%E7%9B%B4%E6%8E%A5return%E7%9A%84%E8%AF%9D%E5%B0%B1%E7%BB%93%E6%9D%9F%E4%BA%86%EF%BC%8C%E5%90%8E%E7%BB%AD%E7%9A%84i%E8%BF%98%E6%B2%A1%E6%9C%89%E9%81%8D%E5%8E%86%E5%91%A2%EF%BC%8C%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E7%82%B9%E9%83%BD%E5%9C%A8%E6%B3%A8%E9%87%8A%E9%87%8C%E4%BA%86"><span class="nav-number">17.3.</span> <span class="nav-text">题解：最快的一版答案，重点在剪枝去重(我XXX)，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-3"><span class="nav-number">17.4.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-1-27"><span class="nav-number">18.</span> <span class="nav-text">leetcode 344. 反转字符串 1.27</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%BC%E4%B9%8E%E6%98%AF%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E9%9B%86"><span class="nav-number">18.1.</span> <span class="nav-text">似乎是最简单的一集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-15"><span class="nav-number">18.2.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E6%9D%A5%EF%BC%8C%E5%9B%9B%E7%A7%8D"><span class="nav-number">18.3.</span> <span class="nav-text">题解：来，四种</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II-1-27"><span class="nav-number">19.</span> <span class="nav-text">leetcode 541. 反转字符串 II 1.27</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E5%B0%B1%E6%98%AF%E4%B8%8D%E4%BC%9A%E2%80%A6%E2%80%A6"><span class="nav-number">19.1.</span> <span class="nav-text">问就是不会……</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-16"><span class="nav-number">19.2.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AC%AC%E4%B8%80%E7%A7%8D%E7%9B%B4%E6%8E%A5%E7%94%A8reverse%E5%87%BD%E6%95%B0%EF%BC%8C%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0reverse%E5%87%BD%E6%95%B0"><span class="nav-number">19.3.</span> <span class="nav-text">题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-4"><span class="nav-number">19.4.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode151-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-25-3-7"><span class="nav-number">20.</span> <span class="nav-text">leetcode151 151. 反转字符串中的单词 25.3.7</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E6%88%91%E5%9B%9E%E6%9D%A5%E5%95%A6-%E4%B8%80%E6%95%B4%E4%B8%AA2%E6%9C%88%E4%BB%BD%E5%9C%A8%E7%84%A6%E8%99%91%E5%92%8C%E8%87%AA%E6%88%91%E5%86%85%E8%80%97%E4%B8%AD%E5%BA%A6%E8%BF%87%E2%80%A6%E2%80%A6"><span class="nav-number">20.1.</span> <span class="nav-text">孩子我回来啦 一整个2月份在焦虑和自我内耗中度过……</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-17"><span class="nav-number">20.2.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E9%97%AE%E5%B0%B1%E6%98%AF%E7%9C%8BCarl%E7%9A%84%E4%B9%A6%EF%BC%8C%E7%8E%B0%E5%9C%A8%E8%A7%89%E5%BE%97%E4%B9%A6%E6%AF%94%E8%A7%86%E9%A2%91%E6%9D%A5%E7%9A%84%E8%88%92%E6%9C%8D%E3%80%82%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E7%A9%BA%E6%A0%BC%EF%BC%8C%E6%B3%A8%E6%84%8F%E7%82%B9%E9%83%BD%E5%9C%A8%E6%B3%A8%E9%87%8A%E9%87%8C%E4%BA%86"><span class="nav-number">20.3.</span> <span class="nav-text">题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-455-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2-25-3-8"><span class="nav-number">21.</span> <span class="nav-text">leetcode 455 455. 分发饼干 25.3.8</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-18"><span class="nav-number">21.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E5%85%88%E6%8E%92%E4%B8%AA%E5%BA%8F%EF%BC%8C%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E7%9C%8B%E9%A5%BC%E5%B9%B2%E8%83%BD%E6%BB%A1%E8%B6%B3%E5%93%AA%E4%BA%9B%E5%B0%8F%E5%AD%A9"><span class="nav-number">21.2.</span> <span class="nav-text">题解：先排个序，从小到大看饼干能满足哪些小孩</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-376-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97-25-3-10"><span class="nav-number">22.</span> <span class="nav-text">leetcode 376 376. 摆动序列 25.3.10</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-19"><span class="nav-number">22.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E8%B4%AA%E5%BF%83%EF%BC%8C%EF%BC%88%E4%BD%86%E6%98%AF%E6%88%91%E6%B2%A1%E6%84%9F%E8%A7%89%E5%87%BA%E6%9D%A5%EF%BC%89%E8%A6%81%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%E4%B8%8D%E5%8D%95%E8%B0%83%E4%BD%86%E6%9C%89%E5%B9%B3%E5%9D%A1%E5%92%8C%E5%8D%95%E8%B0%83%E6%9C%89%E5%B9%B3%E5%9D%A1%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5%E3%80%82%E5%B0%B1%E5%BD%93%E4%BD%9C%E6%98%AF%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%A7%AF%E7%B4%AF%E5%90%A7%EF%BC%8C%E8%83%8C%E4%B8%8B%E6%9D%A5%E5%B0%B1%E5%A5%BD%E4%BA%86%E3%80%82"><span class="nav-number">22.2.</span> <span class="nav-text">题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-53-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-25-3-14"><span class="nav-number">23.</span> <span class="nav-text">leetcode 53 53. 最大子数组和 25.3.14</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-20"><span class="nav-number">23.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%EF%BC%8C%E8%B4%AA%E5%BF%83%E8%B4%AA%E5%9C%A8%E5%93%AA%E9%87%8C%E3%80%82%E5%AE%83%E9%9C%80%E8%A6%81%E6%89%BE%E7%9A%84%E6%98%AF%E5%B1%80%E9%83%A8%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%8C%E9%80%9A%E8%BF%87%E5%B1%80%E9%83%A8%E6%9C%80%E4%BC%98%E6%89%BE%E5%88%B0%E5%85%A8%E5%B1%80%E6%9C%80%E4%BC%98%E3%80%82%E8%BF%99%E9%A2%98%E4%B8%BB%E8%A6%81%E6%98%AF%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AFnums-i-1-%E3%80%82%E4%B8%8D%E6%98%AF%E5%9C%A8%E9%81%87%E5%88%B0%E8%B4%9F%E6%95%B0%E5%B0%B1%E4%B8%8B%E4%B8%80%E4%B8%AA%E3%80%82%E5%8F%AA%E8%A6%81count%E8%BF%98%E6%98%AF-gt-0%E5%B0%B1%E8%BF%98%E5%AF%B9%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%B0%E6%9C%89%E5%A2%9E%E5%A4%A7%E4%BD%9C%E7%94%A8%E3%80%82%E6%98%AF%E5%9C%A8count-lt-0%E6%89%8D%E8%A6%81%E8%B7%B3%E8%BF%87%E3%80%82"><span class="nav-number">23.2.</span> <span class="nav-text">题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums[i+1]。不是在遇到负数就下一个。只要count还是&gt;0就还对下一个数有增大作用。是在count&lt;0才要跳过。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-122-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II-25-3-15"><span class="nav-number">24.</span> <span class="nav-text">leetcode 122 122. 买卖股票的最佳时机 II 25.3.15</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-21"><span class="nav-number">24.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E8%B4%AA%E5%BF%83%E3%80%82%E6%AF%8F%E6%AC%A1%E9%83%BD%E5%85%B3%E6%B3%A8%E5%B1%80%E9%83%A8%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E7%84%B6%E5%90%8E%E6%9C%80%E5%90%8E%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BE%97%E5%88%B0%E5%85%A8%E5%B1%80%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">24.2.</span> <span class="nav-text">题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-55-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-25-3-17"><span class="nav-number">25.</span> <span class="nav-text">leetcode 55 55. 跳跃游戏 25.3.17</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-22"><span class="nav-number">25.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-1"><span class="nav-number">25.2.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82%E7%9C%8B%E5%88%B0%E9%A2%98%E9%9D%A2%E5%B0%B1%E8%A7%89%E5%BE%97%E5%8F%AA%E8%A6%81%E8%83%BD%E5%88%B0%E8%BE%BE%E6%9C%80%E8%BF%9C%E7%9A%84%E5%9C%B0%E6%96%B9%E5%B0%B1%E8%A1%8C%EF%BC%8C%E5%8F%96max%E6%9C%80%E9%87%8D%E8%A6%81%E3%80%82%E7%BB%93%E6%9E%9C%E4%B8%80%E4%BA%A4%E5%8F%91%E7%8E%B0%E4%BA%86%E4%B8%80%E5%A0%86%E9%97%AE%E9%A2%98%EF%BC%8C%E9%82%A3%E4%B8%89%E4%B8%AAif%E6%98%AF%E5%AF%B9%E7%9D%80%E9%94%99%E8%AF%AF%E6%A0%B7%E4%BE%8B%E6%94%B9%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E6%8D%82%E8%84%B8%EF%BC%89"><span class="nav-number">25.2.1.</span> <span class="nav-text">我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%89%88%E6%9C%AC%EF%BC%8C%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%94%A8%E4%BA%86cover%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%98%E7%9B%B4%E6%8E%A5%E8%AE%A9i-lt-cover%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%B0%B1%E5%8D%A1%E6%AD%BB%E4%BA%86%E5%AE%83%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%88%91%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">25.2.2.</span> <span class="nav-text">代码随想录版本，更加简洁，直接用了cover，然后还直接让i&lt;&#x3D;cover，直接就卡死了它的范围，就不会出现我自己写的那些问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-45-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II-25-3-23"><span class="nav-number">26.</span> <span class="nav-text">leetcode 45 45. 跳跃游戏 II 25.3.23</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-23"><span class="nav-number">26.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E8%A6%81%E6%89%BE%E6%9C%80%E5%B0%91%E6%AD%A5%E6%95%B0%EF%BC%8C%E5%B0%B1%E6%98%AF%E7%9C%8B%E5%BD%93%E6%AF%8F%E4%B8%80%E6%AC%A1%E7%9A%84cover%E8%83%BD%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%82%E5%A6%82%E6%9E%9C%E8%83%BD%E5%88%B0%E6%9C%80%E8%BF%9C%E7%9A%84%E5%9C%B0%E6%96%B9%E4%BD%86%E6%98%AF%E8%BF%98%E5%88%B0%E4%B8%8D%E4%BA%86nums-size-1%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E5%B0%86ans-%E3%80%82"><span class="nav-number">26.2.</span> <span class="nav-text">题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums.size()-1的话，就需要将ans++。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-274-274-H-%E6%8C%87%E6%95%B0-25-3-23"><span class="nav-number">27.</span> <span class="nav-text">leetcode 274 274. H 指数 25.3.23</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-24"><span class="nav-number">27.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E6%80%AA%E6%88%91%E5%A4%AA%E8%8F%9C%E4%BA%86%EF%BC%8C%E8%BF%99%E8%BF%98%E6%98%AF%E7%9C%8B%E4%BA%86%E9%A2%98%E8%A7%A3%E6%89%8D%E4%BC%9A%E7%9A%84%EF%BC%8C%E5%8E%9F%E6%9D%A5%E6%88%91%E6%B2%A1%E6%83%B3%E5%88%B0%E3%80%82%E7%9B%B4%E6%8E%A5%E5%80%92%E5%8F%99%E6%8E%92%E5%BA%8F%E4%B8%80%E4%B8%8B%E5%B0%B1%E5%A5%BD%E4%BA%86%EF%BC%8C%E5%86%8D%E7%9C%8B%E4%B8%80%E4%B8%8B%E5%88%B0%E5%93%AA%E9%87%8C%E5%AE%83%E7%9A%84%E4%B8%8B%E6%A0%87%E8%B7%9Fi-1%E5%B0%8F%E4%BA%86%E5%B0%B1%E6%98%AF%E7%AD%94%E6%A1%88"><span class="nav-number">27.2.</span> <span class="nav-text">题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i+1小了就是答案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-LCR-134-Pow-x-n-25-3-28"><span class="nav-number">28.</span> <span class="nav-text">leetcode LCR 134. Pow(x, n) 25.3.28</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-25"><span class="nav-number">28.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%94%BE%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%90%A7"><span class="nav-number">28.2.</span> <span class="nav-text">题解：直接放快速幂的吧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GPT%E8%80%81%E5%B8%88%E5%AF%B9%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="nav-number">28.2.1.</span> <span class="nav-text">GPT老师对于代码的解析：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%90%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">28.2.1.1.</span> <span class="nav-text">逐行分析：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">28.2.2.</span> <span class="nav-text">例子分析：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">28.2.2.1.</span> <span class="nav-text">计算步骤：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99-25-3-28"><span class="nav-number">29.</span> <span class="nav-text">leetcode 134. 加油站 25.3.28</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-26"><span class="nav-number">29.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A%E5%9C%A8%E6%AF%8F%E6%AC%A1%E9%81%87%E5%88%B0cursum-lt-0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%B1%E8%AF%81%E6%98%8E%E8%AF%B4%E8%B5%B7%E7%82%B9%E8%A6%81%E4%BB%8E%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B"><span class="nav-number">29.2.</span> <span class="nav-text">题解：在每次遇到cursum&lt;0的时候，就证明说起点要从下一个开始</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="defy_odd"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">defy_odd</p>
  <div class="site-description" itemprop="description">宝剑锋从磨砺出，梅花香自苦寒来</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/defyodd" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;defyodd" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto::interestinglyxky@163.com" title="E-Mail → mailto::interestinglyxky@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">defy_odd</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">90k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:22</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共36.8k字</span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
