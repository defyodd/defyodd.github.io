<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2.28随笔</title>
    <url>/2.28%20%E9%9A%8F%E7%AC%94.md/</url>
    <content><![CDATA[<p>2.28 随笔</p>
<p>莫名感慨</p>
<p>现在是25.2.28，中午12：21.早上的经历，不知怎么，就突然挺感慨的。</p>
<p>早上起来，心里有点郁闷，看了看手机，到了9点才从宿舍走。（对不起姐，我又一次没按照计划来了呜呜呜）</p>
<p>到了图书馆，开始读英语，读完之后刚好图书馆里面的校史馆开了，就进去看了几眼，一看就是1小时。</p>
<p>我以前没想到原来学校有这么多的故事，都是之前未曾知晓的。</p>
<p>包括以前的校门，这里放着的是原本的真实牌匾，就忽然有一种时空错乱，似乎一瞬间回到过去的感觉。</p>
<p>忽然感慨历史的深邃。</p>
<p>看完之后，本来应该开始学习的，但是打开了知乎，看到了一个跟自己的发小结婚之后挺幸福的故事。故事挺长的，看完之后觉得说，两个人的感情还是要慢慢培养，细水长流。这样才能稳定，巩固根基。</p>
<p>然后，打开电脑，想着说把之前的博客删一下，然后莫名其妙的翻到了yt，yh，yc的blog。我感慨于他们的blog的精美，感慨于中9和我之间的差距，感慨于贵系和莫2cs之间不可越过的鸿沟。虽然更新时间已经都是在去年了，已经一年整没有更新了，但是我看到了之后还是觉得震撼。跟我的blog一对比，那差的不是一点半点。</p>
<p>又翻到一个我贵系的同学的同学，看到了他的博客，他把简历放上去了。六级678.嗯，比我多了130多分。可能这就是贵系的实力吧。是我这种末2鼠鼠触及不到的。只能说，从他们的身上学到东西吧。</p>
<p>真的，人与人的差距真的太大了。这群高中同学一个比一个逆天。</p>
<p>但是好像，我也不差，在这里也还有一席之地。如果真的在一个中9的本科的话，我觉得保研就不会有我什么事了，老老实实准备准备考研吧。但是现在，离保研还是有一点点差距的。还有一学期，慢慢来吧，慢慢找回自己的状态，我相信我可以的。</p>
<p>吃个饭回去吧，下午再开始学习。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>3.23随笔</title>
    <url>/3.23.md/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2e67ae86bc80a55f80b6fd4ddf8a5f63be97b9044fdfa5f4baf746c83457f917">265a233087301c33a36d98e48973fc012fcabe56687dc9ff141cc2c52bc7e27b03931327efb58c05c657dc96d41948e8053a3ded407e68276ff1e1ca328b35a385f408887e2368c15914bd367de0edc097a6bbc77558f17f3d84d9db6ea642b085f77af66baa1ae39b52ede688ee3eff92d58ebbfd2082483a34b9c9888e677dab093c8fc7b5391ebc5a0cb97889d5549c916fd18571d0c0f48331b9c79292203d419698aabc6958f632b3a744c9935a882431a54e9558e6fda2e5e122180c72ce5dae841a979a50e27c7292ee97a3225972505433b70b0dbfb5102c4da43bf5ddf7eb7dfee46a6cd359c25140404ef7c6bb1abf986e141af853b9f5a4bf8a57f40818a3823bd675448de12861c4f2f93012a8688f4363cd5dcd67acf5060ca3bf5248d3a22739dd71a405eb7f84b9ae</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>3.29随笔</title>
    <url>/3.29.md/</url>
    <content><![CDATA[<p>记录一下</p>
<p>第一次自己一个人来海底捞</p>
<p>希望我的四月不像三月这么抽象，这么离谱</p>
<p>人间四月芳菲尽，山寺桃花始盛开。</p>
<p>你是人间的四月天，笑响点亮了四面风</p>
<p>You are the April of this world</p>
<p>Yes, you are.</p>
<p>The best friend is youself.</p>
<p>25.3.29 于海淀大悦城海底捞</p>
<img src="/3.29.md/1.jpg" class="" title="img">
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>3.21随笔</title>
    <url>/3.21.md/</url>
    <content><![CDATA[<h2 id="不是伤害你的人让你成长，而是你对被伤害的反思让你成长。所以不要故作大度地感谢伤害你的人-——列夫·托尔斯泰"><a href="#不是伤害你的人让你成长，而是你对被伤害的反思让你成长。所以不要故作大度地感谢伤害你的人-——列夫·托尔斯泰" class="headerlink" title="不是伤害你的人让你成长，而是你对被伤害的反思让你成长。所以不要故作大度地感谢伤害你的人  ——列夫·托尔斯泰"></a>不是伤害你的人让你成长，而是你对被伤害的反思让你成长。所以不要故作大度地感谢伤害你的人  ——列夫·托尔斯泰</h2><p>这一周发生了好多事情</p>
<p>总想写点什么，就是心里挺怅然的</p>
<p>一方面是第二课堂的统计，结果还可以</p>
<p>另一方面，也是更重要的方面，我打算放手了</p>
<p>从周二ta发的那几条消息给我之后，我就没有回过，我也不想回了</p>
<p>因为已经失去了继续的所有意义</p>
<p>就当作是对于以前发生的事情的一个了断</p>
<p>我也需要继续往前看了</p>
<p>昨天中期答辩完，跟qi总和dai姐聊了这件事情</p>
<p>豁然开朗，醍醐灌顶</p>
<p>我不知道我周二周三周四上午是怎么过来的</p>
<p>但直到昨天下午，突然又觉得这个世界，没有那么不堪</p>
<p>确实，自己的未来全是为了一个人的话，也是对自己的一种不负责</p>
<p>她们从另一个角度给了我更好的解释</p>
<p>这个视角是之前未曾看到，或者说看不到的</p>
<p>突然就释然了</p>
<p>我明白了，不是我的问题，是你的问题</p>
<p>虽然说不可能马上就把这个东西完全至于脑后，但昨天她们给了我一个提醒，或者说是给了我一种勇气</p>
<p>曾经深陷其中，但如今的我需要走出来了</p>
<p>周二的时候，我是知道了，我要放手了</p>
<p>直到昨天，我突然一下就明白了，我可以放手了</p>
<p>这种转变，真的就在一瞬间</p>
<p>虽然还需要一点时间，但至少不会像前几天那样一点事情都干不下去了</p>
<p>需要开始一段新的日子了</p>
<p>对，我觉得我差不多准备好了</p>
<p>人总是要经历一些事情才能成长，才能长大</p>
<p>但是我一定要感谢昨天愿意听我故事的两位姐，感谢当时选的队友，感谢当时让出去的负责人，感谢当时的决定</p>
<p>没有之前那样的选择，我也没有这么好的队友，没有这么好的成果（虽然我没有，是我的问题），没有在我困惑的时候能解惑、能倾诉的地方</p>
<p>感谢之前的我的选择</p>
<p>可能这一切都是那么刚好</p>
<p>虽然可能她们觉得没有什么很重要的，就是听点八卦</p>
<p>但对我来说，她们的想法给了我很大的启发，这就足矣了</p>
<p>我还需要一点时间来适应，但我相信我可以的</p>
<p>相比于课内的知识，有时候这些东西比所谓的rk，paper更加重要</p>
<p>它们是我一辈子的财富</p>
<p>只有沿途的风景才最为珍贵</p>
<p>可能所有的东西，都是已经命中注定的，所有的一切都是有前奏的</p>
<p>What’s  past is prologue.</p>
<p>就当作成长路上的养分，人生路途中需要经历的东西</p>
<p>每个人都有自己的节奏，有些人快，有些人慢</p>
<p>I am a slow walker, but i never walk backward.</p>
<p>慢一点没什么大不了</p>
<p>一切都还得及</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GPS</title>
    <url>/GPS.md/</url>
    <content><![CDATA[<hr>
<p><a href="https://www.semanticscholar.org/paper/Greedy-Policy-Search%3A-A-Simple-Baseline-for-Molchanov-Lyzhov/8286fbad6d4712d950689930720134bc8828963f?sort=relevance&amp;queryString=segmentation"> Greedy Policy Search: A Simple Baseline for Learnable Test-Time Augmentation | Semantic Scholar</a></p>
<p><a href="https://github.com/SamsungLabs/gps-augment?tab=readme-ov-file">SamsungLabs/gps-augment: Simple but high-performing method for learning a policy of test-time augmentation (github.com)</a></p>
<span id="more"></span>
<p>在一个已经训练好的网络上将测试数据增广，利用这些数据来测量网络的不确定性</p>
<p>GPS（greedy policy search）：a simple algorithm that learns a policy for test-time data augmentation based on the predictive performance on a validation set. </p>
<p>一个简单的算法，<strong>根据验证集的预测性能</strong>来学习测试时间数据增强的策略。</p>
<p>In an ablation study, we show that <strong>optimizing the calibrated log-likelihood**</strong>（优化校准的对数似然）<strong> (Ashukha et al., 2020) is </strong>a crucial part<strong> of the policy search algorithm, while the default objectives—</strong>accuracy and loglikelihood—lead to a significant drop in the final performance.**</p>
<p>定义TTA policy为一系列子政策的集合，每个子政策又包含Ns个连续的图片变换。</p>
<p>步骤：</p>
<p>1、 先用CIFAR10数据集训练VGG模型，并用randaugment增广数据</p>
<p>2、 将这些增广好的数据进行预测处理并选取其中的一部分作为备选池。本文共选取1101个子政策</p>
<p>3、 用校准的对数似然来评价，选择让可以在聚合预测时提供最大提升的子政策进入pool中</p>
<p><strong>Prediction通过求不同子政策的平均得到</strong></p>
<img src="/GPS.md/inference.png" class="" title="img">
<p>GPS的核心算法（利用贪心和校准的对数似然）</p>
<img src="/GPS.md/algoriothm.png" class="" title="img">
<p>评判标准：校准的对数似然（对数似然加上temperature scaling）</p>
<p>GPS是一个学习型（learnable）的策略，它在过程中不断选择好的东西放到pool中</p>
<p>域内的表现不错，但是还可以加上聚合来加强表现。</p>
<p>原本的指标（metric）是accuracy和log-likelihood。但是LL可能会误把好模型忽略（因为刚好无法校准）但可以用温度缩放来调整回来。cLL可以得到更好的M</p>
<p>领域转移的健壮性：CIFAR10-C, CIFAR-100-C and ImageNet-C datasets with 15 corruptions C from groups noise, blur, weather and digital.（数据）对每个确定的level都计算错误率，对每个corruption都计算平均</p>
<p>一般来看，在干净的验证数据上训练的策略对损坏的数据有很好的效果。（换句话说，在哪里GPS效果都很好） transfer GPS policy 效果在不同的数据集上不错</p>
<p>结合聚合方法效果也不错</p>
<p>在原始的数据增广上也有不错的表现</p>
<p>Reference：</p>
<p><a href="https://zhuanlan.zhihu.com/p/620688513">Pytorch格式 .pt .pth .bin .onnx 详解 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/m0_51004308/article/details/118001835">Pytorch学习笔记(七):F.softmax()和F.log_softmax函数详解-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qiankendeNMY/article/details/126508781?spm=1018.2226.3001.9630.1&amp;extra[title]=Python—argparse模块&amp;extra[utm_source]=vip_chatgpt_common_pc_toolbar&amp;extra[utm_medium]=">Python—argparse模块_parser.add_argument(‘—data’, type=str, default=’’-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/tsinghuahui/article/details/89279152">python argparse中action的可选参数store_true的作用_argparse store_true-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/u010804417/article/details/92843528">伪代码书写规则_伪代码怎么写-CSDN博客</a>（在伪码中，符号∅通常表示空集或空值）</p>
<p><a href="https://zhuanlan.zhihu.com/p/26614750">一文搞懂极大似然估计 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/Elenstone/article/details/105677886">机器学习最易懂之贝叶斯模型详解与python实现_pytorch实现贝叶斯决策模型-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_23933415/article/details/111212898">模型的参数verbose用法详解_verbose参数-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_44912159/article/details/104921422">论文中的常见缩写(w.r.t/i.e./et al等)的意思-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/fengbingchun/article/details/124648766">深度学习中的优化算法之带Momentum的SGD_momentum sgd-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/wangxuecheng666/article/details/109246126">StratifiedShuffleSplit（）函数的详细理解-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_37297763/article/details/116847455">Pytorch学习（十三）python中<em>args和*</em>kwargs的用法_pytorch args.-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/Just_do_myself/article/details/123751148?spm=1018.2226.3001.9630.1&amp;extra[title]=深度学习之动态调整学习率LR&amp;extra[utm_source]=vip_chatgpt_common_pc_toolbar&amp;extra[utm_medium]=">深度学习之动态调整学习率LR_动态学习率-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_42079689/article/details/102873766">PyTorch的nn.Linear（）详解_nn.linear()-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_42843425/article/details/122518502">model.parameters()的理解与使用-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_41813454/article/details/135129279?spm=1018.2226.3001.9630.1&amp;extra[title]=别再混淆了！model.eval(">别再混淆了！model.eval()和torch.no_grad()的区别一次讲清楚-CSDN博客</a>和torch.no_grad()的区别一次讲清楚&amp;extra[utm_source]=vip_chatgpt_common_pc_toolbar&amp;extra[utm_medium]=)</p>
<p><a href="https://zhuanlan.zhihu.com/p/38121870">机器学习之K折交叉验证 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_39478403/article/details/121107057">【机器学习】浅谈 归纳偏置 (Inductive Bias)-CSDN博客</a></p>
<p>· store_true 是指带触发 action 时为真，不触发则为假， 即默认 False ，传参 则 设置为 True<br> · store_false 则与之相反</p>
<img src="/GPS.md/ref1.png" class="" title="img">
<img src="/GPS.md/ref2.png" class="" title="img">
<img src="/GPS.md/ref3.png" class="" title="img">
<img src="/GPS.md/ref4.png" class="" title="img">
<img src="/GPS.md/ref5.png" class="" title="img">
<p>enumerate函数，它可以同时返回列表中的元素和它们的索引</p>
<img src="/GPS.md/ref6.png" class="" title="img">
<img src="/GPS.md/ref7.png" class="" title="img">
<img src="/GPS.md/ref8.png" class="" title="img">
<img src="/GPS.md/ref9.png" class="" title="img">
<p>ablation study (消融实验)</p>
<p><a href="https://zhuanlan.zhihu.com/p/644502891">一文搞懂什么是ablation study (消融实验） - 知乎 (zhihu.com)</a><br> adversarial attacks 对抗攻击 在某些微小影响下会导致巨大偏差</p>
<p><a href="https://zhuanlan.zhihu.com/p/104532285">CV||对抗攻击领域综述（adversarial attack） - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/293065153">Google开箱即用数据增强RandAugment | NeurIPS 2020 - 知乎 (zhihu.com)</a></p>
<p>原始的自动数据增强方式，先在一个单独的小数据集代理任务（可以理解成小/子数据集，子任务 ）上进行，然后再迁移到更大数据的目标任务中去。作者提出了一种实用的自动数据增强算法RandAugment。该方法无需在子任务上进行搜索验证。但为了减少数据增强的参数搜索空间，作者设计了一种简单的格点搜索（simple grid search）方法以学习/获取一种数据增强的策略。<strong>RandAugment只有两个参数：N和M。 其中N为在每次增强时使用N次操作（使用的这N个操作，都是从操作集中等概率抽取的，例如操作集中有14种操作，则每种操作被选中的概率为1/14，每张图像的N次增强中，选到的操作可能是一样的），M为正整数，表示所有操作在应用时，幅度都为M（旋转多少）</strong>。</p>
<p><strong>用于数据增广</strong><br><img src="/GPS.md/ref10.png" class="" title="img"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>校准</tag>
      </tags>
  </entry>
  <entry>
    <title>Mask-TS and ODC-SA net</title>
    <url>/Mask-TS-and-ODC-SA-net.md/</url>
    <content><![CDATA[<p>学习学长的idea<br><span id="more"></span></p>
<h1 id="Mask-TS"><a href="#Mask-TS" class="headerlink" title="Mask-TS"></a>Mask-TS</h1><img src="/Mask-TS-and-ODC-SA-net.md/mask-ts.png" class="" title="image-20240705115352035">
<p>将原图、模型输出logits、概率图、不确定性图分别输入到4个一样的卷积网络当中，4个通过卷积之后代表它们考虑了像素点之间的位置关系。<strong>（只要通过了卷积网络就已经考虑了像素之间的位置关系）</strong>这四个卷积的输出放入一个注意力通道当中，通过自适应权重进行相加。</p>
<p>Hi和Pi这两个分支分别在增强边缘形状和更仔细地处理预测的真值方面发挥了作用，而x i包含丰富的原始信息，z i拥有与分割有关的特征，因为它源于一个分割网络</p>
<p>被认为是背景的部分就保持原始全局T0不变，被认为是病变区域的就用校准之后pre-output T‘。<br><!-- more --></p>
<h1 id="Mask-loss"><a href="#Mask-loss" class="headerlink" title="Mask-loss"></a>Mask-loss</h1><img src="/Mask-TS-and-ODC-SA-net.md/mask-loss1.png" class="" title="image-20240705183615243">
<img src="/Mask-TS-and-ODC-SA-net.md/mask-loss2.png" class="" title="image-20240705183653977">
<p>先将label和prediction合并，然后将calibrated logits的背景视为白色，忽略掉背景，将prediction黑白反转。再将两图合并，得到一个关注边缘的图像。再利用的二分类交叉熵损失函数。</p>
<h2 id="confidence-and-accuracy"><a href="#confidence-and-accuracy" class="headerlink" title="confidence and accuracy"></a>confidence and accuracy</h2><p>In learning algorithm, Confidence defines the probability of the event (or probability of input to fall in different classes). </p>
<p><strong>If a class has high probability then it has high confidence</strong>. Confidence value can be calculated for single input as well giving the meaning as how much the algorithm is confident for that class.</p>
<p>On the other hand, <strong>accuracy defines the skill of the learning algorithm to predict accurately.</strong> It defines the percentage of correct predictions made from all predictions.</p>
<h2 id="ECE是越小越好"><a href="#ECE是越小越好" class="headerlink" title="ECE是越小越好"></a>ECE是越小越好</h2><h1 id="ODC-SA-Net"><a href="#ODC-SA-Net" class="headerlink" title="ODC-SA Net"></a>ODC-SA Net</h1><p>to deal with multi-directional features and drastic changes in scale.多方向的特征和规模的急剧变化。</p>
<h2 id="existing-problems"><a href="#existing-problems" class="headerlink" title="existing problems"></a>existing problems</h2><ol>
<li><p>In the target images containing extremely hidden polyps, the angles of them change randomly with the movement of the lens, which makes the features of the polyps no longer representative in a fixed or specific few directions.在含有极度隐藏的息肉的目标图像中，它们的角度随着镜头的移动而随机变化，这使得息肉的特征不再代表固定或特定的几个方向。</p>
</li>
<li><p>The size of the hidden object in the polyp image varies dramatically息肉图像中隐藏物体的大小变化很大</p>
</li>
<li><p>Most of the existing methods ignore the importance of feature reorganization after the multi-layer feature fusion operation for the segmentation problem, which makes the rich semantic information obtained by the encoder cannot be fully utilized.现有的方法大多忽略了多层特征融合操作后的特征重组对分割问题的重要性，这使得编码器获得的丰富语义信息不能得到充分的利用。</p>
</li>
</ol>
<img src="/Mask-TS-and-ODC-SA-net.md/ODC.png" class="" title="image-20240714165544654">
<h2 id="ODC：Orthogonal-Direction-Enhancement-正交方向增强"><a href="#ODC：Orthogonal-Direction-Enhancement-正交方向增强" class="headerlink" title="ODC：Orthogonal Direction Enhancement  正交方向增强"></a>ODC：Orthogonal Direction Enhancement  正交方向增强</h2><blockquote>
<p>正交方向卷积（ODC）块可以通过形成正交特征向量基础，利用转置的矩形卷积核提取多方向特征，解决了随机特征方向变化的问题，减少了计算负荷。</p>
</blockquote>
<img src="/Mask-TS-and-ODC-SA-net.md/ODC-key.png" class="" title="image-20240715142552391">
<h3 id="需要解决的问题："><a href="#需要解决的问题：" class="headerlink" title="需要解决的问题："></a>需要解决的问题：</h3><p>different location and shooting direction of the colonoscopy-lens, the usual convolution kernel will miss features in specific directions due to the rotation of the image or the target because of its square shape and fixed sliding direction</p>
<p>由于结肠镜-透镜的不同位置和拍摄方向，通常的卷积核会因为图像或目标的旋转而错过特定方向的特征，因为它是方形的，而且滑动方向固定。</p>
<p>solves the problem of random changes in target feature directions？</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>一对转置矩形卷积核（1×3和3×1）分别提取最深层图像的每个通道的垂直和水平的特征来形成一个正交特征基准</p>
<p>每个通道特征可以用一个线性表达式来表示:</p>
<script type="math/tex; mode=display">
\pmb{f}^k = a_k\pmb{r}^k + b_k\pmb{c}^k = a_kr^k\pmb{i} + b_kc^k\pmb{j}</script><p>网络下一层的任何通道的特征图应该是上一层的所有通道与任何方向的特征的组合</p>
<img src="/Mask-TS-and-ODC-SA-net.md/gonshi1.png" class="" title="image-20240715142428834">
<p>具体操作：</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.661ex;" xmlns="http://www.w3.org/2000/svg" width="15.208ex" height="2.891ex" role="img" focusable="false" viewBox="0 -985.6 6722 1277.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="TeXAtom" transform="translate(837.3,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(676,-284.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1518.6,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="msup" transform="translate(2463.4,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="211D" d="M17 665Q17 672 28 683H221Q415 681 439 677Q461 673 481 667T516 654T544 639T566 623T584 607T597 592T607 578T614 565T618 554L621 548Q626 530 626 497Q626 447 613 419Q578 348 473 326L455 321Q462 310 473 292T517 226T578 141T637 72T686 35Q705 30 705 16Q705 7 693 -1H510Q503 6 404 159L306 310H268V183Q270 67 271 59Q274 42 291 38Q295 37 319 35Q344 35 353 28Q362 17 353 3L346 -1H28Q16 5 16 16Q16 35 55 35Q96 38 101 52Q106 60 106 341T101 632Q95 645 55 648Q17 648 17 665ZM241 35Q238 42 237 45T235 78T233 163T233 337V621L237 635L244 648H133Q136 641 137 638T139 603T141 517T141 341Q141 131 140 89T134 37Q133 36 133 35H241ZM457 496Q457 540 449 570T425 615T400 634T377 643Q374 643 339 648Q300 648 281 635Q271 628 270 610T268 481V346H284Q327 346 375 352Q421 364 439 392T457 496ZM492 537T492 496T488 427T478 389T469 371T464 361Q464 360 465 360Q469 360 497 370Q593 400 593 495Q593 592 477 630L457 637L461 626Q474 611 488 561Q492 537 492 496ZM464 243Q411 317 410 317Q404 317 401 315Q384 315 370 312H346L526 35H619L606 50Q553 109 464 243Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(755,365.5) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(259.6,394) scale(0.707)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="907.1" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1147.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mfrac" transform="translate(1925.1,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mn" transform="translate(237,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="941" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3106.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(3884.2,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>  </p>
<p> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="50.185ex" height="2.587ex" role="img" focusable="false" viewBox="0 -985.6 22181.7 1143.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mspace"></g><g data-mml-node="msub" transform="translate(55.3,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(484,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1111,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="msup" transform="translate(2055.8,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="211D" d="M17 665Q17 672 28 683H221Q415 681 439 677Q461 673 481 667T516 654T544 639T566 623T584 607T597 592T607 578T614 565T618 554L621 548Q626 530 626 497Q626 447 613 419Q578 348 473 326L455 321Q462 310 473 292T517 226T578 141T637 72T686 35Q705 30 705 16Q705 7 693 -1H510Q503 6 404 159L306 310H268V183Q270 67 271 59Q274 42 291 38Q295 37 319 35Q344 35 353 28Q362 17 353 3L346 -1H28Q16 5 16 16Q16 35 55 35Q96 38 101 52Q106 60 106 341T101 632Q95 645 55 648Q17 648 17 665ZM241 35Q238 42 237 45T235 78T233 163T233 337V621L237 635L244 648H133Q136 641 137 638T139 603T141 517T141 341Q141 131 140 89T134 37Q133 36 133 35H241ZM457 496Q457 540 449 570T425 615T400 634T377 643Q374 643 339 648Q300 648 281 635Q271 628 270 610T268 481V346H284Q327 346 375 352Q421 364 439 392T457 496ZM492 537T492 496T488 427T478 389T469 371T464 361Q464 360 465 360Q469 360 497 370Q593 400 593 495Q593 592 477 630L457 637L461 626Q474 611 488 561Q492 537 492 496ZM464 243Q411 317 410 317Q404 317 401 315Q384 315 370 312H346L526 35H619L606 50Q553 109 464 243Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(755,365.5) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(259.6,394) scale(0.707)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="907.1" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1147.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mfrac" transform="translate(1925.1,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mn" transform="translate(237,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="941" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3106.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(3884.2,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(6536.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7536.8,0)"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g><g data-mml-node="mspace" transform="translate(7536.8,0)"></g><g data-mml-node="msub" transform="translate(7592.1,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(466,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(8629.8,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="msup" transform="translate(9574.6,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="211D" d="M17 665Q17 672 28 683H221Q415 681 439 677Q461 673 481 667T516 654T544 639T566 623T584 607T597 592T607 578T614 565T618 554L621 548Q626 530 626 497Q626 447 613 419Q578 348 473 326L455 321Q462 310 473 292T517 226T578 141T637 72T686 35Q705 30 705 16Q705 7 693 -1H510Q503 6 404 159L306 310H268V183Q270 67 271 59Q274 42 291 38Q295 37 319 35Q344 35 353 28Q362 17 353 3L346 -1H28Q16 5 16 16Q16 35 55 35Q96 38 101 52Q106 60 106 341T101 632Q95 645 55 648Q17 648 17 665ZM241 35Q238 42 237 45T235 78T233 163T233 337V621L237 635L244 648H133Q136 641 137 638T139 603T141 517T141 341Q141 131 140 89T134 37Q133 36 133 35H241ZM457 496Q457 540 449 570T425 615T400 634T377 643Q374 643 339 648Q300 648 281 635Q271 628 270 610T268 481V346H284Q327 346 375 352Q421 364 439 392T457 496ZM492 537T492 496T488 427T478 389T469 371T464 361Q464 360 465 360Q469 360 497 370Q593 400 593 495Q593 592 477 630L457 637L461 626Q474 611 488 561Q492 537 492 496ZM464 243Q411 317 410 317Q404 317 401 315Q384 315 370 312H346L526 35H619L606 50Q553 109 464 243Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(755,365.5) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(259.6,394) scale(0.707)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="907.1" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1147.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mfrac" transform="translate(1925.1,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mn" transform="translate(237,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="941" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3106.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(3884.2,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(14111,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(15388.8,0)"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g></g><g data-mml-node="mspace" transform="translate(15388.8,0)"></g><g data-mml-node="msub" transform="translate(15444,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(609,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(16624.7,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="msup" transform="translate(17569.5,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="211D" d="M17 665Q17 672 28 683H221Q415 681 439 677Q461 673 481 667T516 654T544 639T566 623T584 607T597 592T607 578T614 565T618 554L621 548Q626 530 626 497Q626 447 613 419Q578 348 473 326L455 321Q462 310 473 292T517 226T578 141T637 72T686 35Q705 30 705 16Q705 7 693 -1H510Q503 6 404 159L306 310H268V183Q270 67 271 59Q274 42 291 38Q295 37 319 35Q344 35 353 28Q362 17 353 3L346 -1H28Q16 5 16 16Q16 35 55 35Q96 38 101 52Q106 60 106 341T101 632Q95 645 55 648Q17 648 17 665ZM241 35Q238 42 237 45T235 78T233 163T233 337V621L237 635L244 648H133Q136 641 137 638T139 603T141 517T141 341Q141 131 140 89T134 37Q133 36 133 35H241ZM457 496Q457 540 449 570T425 615T400 634T377 643Q374 643 339 648Q300 648 281 635Q271 628 270 610T268 481V346H284Q327 346 375 352Q421 364 439 392T457 496ZM492 537T492 496T488 427T478 389T469 371T464 361Q464 360 465 360Q469 360 497 370Q593 400 593 495Q593 592 477 630L457 637L461 626Q474 611 488 561Q492 537 492 496ZM464 243Q411 317 410 317Q404 317 401 315Q384 315 370 312H346L526 35H619L606 50Q553 109 464 243Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(755,365.5) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(259.6,394) scale(0.707)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="907.1" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1147.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mfrac" transform="translate(1925.1,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mn" transform="translate(237,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="941" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3106.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(3884.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"></path></g></g></g></g></g></svg></mjx-container>   ?为啥（我只能理解为它用了padding）</p>
<p>一个三层的1×3卷积去提取水平特征<script type="math/tex">r_i</script> 另一个三层的3×1的卷积去提取垂直特征<script type="math/tex">c_i</script></p>
<p>然后将这两个特征通过线性组合合并得到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.043ex" height="1.927ex" role="img" focusable="false" viewBox="0 -694 903 851.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(609,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></p>
<p>最后再进行一个残差连接，把原图接进来，得到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="15.055ex" height="2.669ex" role="img" focusable="false" viewBox="0 -985.6 6654.4 1179.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mpadded"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g><g data-mml-node="mspace"></g><g data-mml-node="msub" transform="translate(55.3,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(824,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1451,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="msup" transform="translate(2395.8,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="211D" d="M17 665Q17 672 28 683H221Q415 681 439 677Q461 673 481 667T516 654T544 639T566 623T584 607T597 592T607 578T614 565T618 554L621 548Q626 530 626 497Q626 447 613 419Q578 348 473 326L455 321Q462 310 473 292T517 226T578 141T637 72T686 35Q705 30 705 16Q705 7 693 -1H510Q503 6 404 159L306 310H268V183Q270 67 271 59Q274 42 291 38Q295 37 319 35Q344 35 353 28Q362 17 353 3L346 -1H28Q16 5 16 16Q16 35 55 35Q96 38 101 52Q106 60 106 341T101 632Q95 645 55 648Q17 648 17 665ZM241 35Q238 42 237 45T235 78T233 163T233 337V621L237 635L244 648H133Q136 641 137 638T139 603T141 517T141 341Q141 131 140 89T134 37Q133 36 133 35H241ZM457 496Q457 540 449 570T425 615T400 634T377 643Q374 643 339 648Q300 648 281 635Q271 628 270 610T268 481V346H284Q327 346 375 352Q421 364 439 392T457 496ZM492 537T492 496T488 427T478 389T469 371T464 361Q464 360 465 360Q469 360 497 370Q593 400 593 495Q593 592 477 630L457 637L461 626Q474 611 488 561Q492 537 492 496ZM464 243Q411 317 410 317Q404 317 401 315Q384 315 370 312H346L526 35H619L606 50Q553 109 464 243Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(755,365.5) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(259.6,394) scale(0.707)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="907.1" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1147.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mfrac" transform="translate(1925.1,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mn" transform="translate(237,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><rect width="941" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3106.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(3884.2,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container></p>
<p>​    </p>
<h2 id="SA-Scale-Aware-扩大感受野-MSFA"><a href="#SA-Scale-Aware-扩大感受野-MSFA" class="headerlink" title="SA: Scale Aware  扩大感受野 MSFA"></a>SA: Scale Aware  扩大感受野 MSFA</h2><blockquote>
<p>Multi-scale Fusion Attention mechanism  多尺度融合注意（MSFA）机制 </p>
<p>emphasize scale changes in both spatial and channel dimensions, enhancing the segmentation accuracy for polyps of varying size 强调了空间和通道维度上的尺度变化，提高了不同大小的息肉的分割精度。</p>
</blockquote>
<img src="/Mask-TS-and-ODC-SA-net.md/msfa.png" class="" title="image-20240724171951166">
<h3 id="需要解决的问题：-1"><a href="#需要解决的问题：-1" class="headerlink" title="需要解决的问题："></a>需要解决的问题：</h3><p>The growth time of polyps in the intestine, the environment and the shooting distance of the colonoscopy lens are different. The polyps contained in the pictures have different sizes, and their color and texture characteristics are very similar to the background.</p>
<p>息肉在肠道、环境中的生长时间和结肠镜镜的拍摄距离是不同的。图片中包含的息肉有不同的尺寸，它们的颜色和纹理特征与背景非常相似。</p>
<p>Most of the existing methods treat scale-varying features as the same and ignore the attention bias caused by their differences in spatial and channel dimensions.</p>
<p>大多数现有的方法将标度变化的特征视为相同，而忽略了由它们在空间和通道维度上的差异引起的注意力偏差。</p>
<h3 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h3><p>提出Spatial Scalable Enhancement Mechanism (S2E) and Channel Scalable Attention Mechanism (CSA)</p>
<p>S2E增强多尺度的空间特征，CSA在通道维度增强多尺度注意力</p>
<p>expand the receptive field in both spatial and channel dimensions by convolutional and pooling parallel dual channels of the high-level feature map Q i containing more semantic information, and use the feature map of the lower layer x3 i , which has more detail information than Q i , to give attention to the deep semantics of objects with different sizes to de-emphasize the influence of background and interference</p>
<p>通过卷积和池化并行的双通道方式扩大高等级特征图<script type="math/tex">Q_i</script>在空间和通道两个维度上的感受野，并使用包含更多详细信息的底层特征的<script type="math/tex">x^3_i</script>增加对于深层语义分割不同大小的注意力，降低对背景的关注。</p>
<h3 id="S2E：Spatial-Scalable-Enhancement-Mechanism-空间可扩展的增强机制"><a href="#S2E：Spatial-Scalable-Enhancement-Mechanism-空间可扩展的增强机制" class="headerlink" title="S2E：Spatial Scalable Enhancement Mechanism 空间可扩展的增强机制"></a>S2E：Spatial Scalable Enhancement Mechanism 空间可扩展的增强机制</h3><img src="/Mask-TS-and-ODC-SA-net.md/s2e.png" class="" title="image-20240724180802044">
<p>双线并行</p>
<p>一个是包含3个3*3的卷积层，可以获取局部特征信息并通过卷积操作增强其对于小物体的特征信息。</p>
<p>另一个是一个平均池化层，在一些特定区域（2*2大小），平均池化可以保留大目标，减弱小目标（由于更大的目标包含更多的像素点），这样之后新特征图的总体分布和大目标的分布更接近，同时也获得了全局的上下文信息。</p>
<p>它减弱了空间分辨率但增强了全局上下文信息在没有增大计算量的前提下。</p>
<p>在平均池化之后，插值被放大（没有对小物体的削弱进行补偿）来保证和第一个通道上的图片大小一致，并且相加。</p>
<p>这样可以做到融合了空间多尺度信息，同时不用很大的计算量。</p>
<p>Output：<script type="math/tex">S_i</script></p>
<h3 id="CSA：Channel-Scalable-Attention-Mechanism-通道可扩展注意机制"><a href="#CSA：Channel-Scalable-Attention-Mechanism-通道可扩展注意机制" class="headerlink" title="CSA：Channel Scalable Attention Mechanism 通道可扩展注意机制"></a>CSA：Channel Scalable Attention Mechanism 通道可扩展注意机制</h3><img src="/Mask-TS-and-ODC-SA-net.md/csa.png" class="" title="image-20240724220323241">
<p>要解决的问题：Different channels contain different semantic information, and there are scale differences in the targets mapped by these channels.不同的通道包含不同的语义信息，这些通道映射的目标也存在规模差异。</p>
<p>对于小目标：传统的 Point-Wise-Conv + ReLU 提升注意力</p>
<p>对于大目标：先进行平均池化之后再进行 Point-Wise-Conv + ReLU 利用每个通道特征图的像素平均值，在全局信息的引导下获得通道注意力，增加了大尺度特征图的权重</p>
<p>两个分支的输出相加送入Sigmiod得到输出<script type="math/tex">W_i</script>，之后和<script type="math/tex">S_i</script>相点乘之后再和<script type="math/tex">Q_i</script>相加得到<script type="math/tex">D_i</script>   ?学长好像写错了，应该是先和Si点乘之后再和Qi相加</p>
<p>Output：<script type="math/tex">D_i</script></p>
<h3 id="RFA：Residual-Fusion-Attention-剩余融合注意"><a href="#RFA：Residual-Fusion-Attention-剩余融合注意" class="headerlink" title="RFA：Residual Fusion Attention  剩余融合注意"></a>RFA：Residual Fusion Attention  剩余融合注意</h3><img src="/Mask-TS-and-ODC-SA-net.md/rfa.png" class="" title="image-20240726223106998">
<p>通过<script type="math/tex">F^3_i</script> 来指导 <script type="math/tex">D_i</script> 进行浅层和深层特征融合。</p>
<p>这里<script type="math/tex">D_i</script>经过上采样和驻点卷积使得和<script type="math/tex">F^3_i</script>大小一样，同样<script type="math/tex">F^3_i</script>也经过逐点卷积得到相同大小，相加之后经过一个ReLU激活函数和一个Conv block ，之后再进行一次残差连接，最后的通过softmax输出的<script type="math/tex">E_i</script>包含了每个像素的有效信息。最终<script type="math/tex">E_i</script>再和上采样之后的<script type="math/tex">D_i</script>点乘，自动关注目标区域。</p>
<p>Output:<script type="math/tex">C_i</script></p>
<h2 id="Extraction-with-Re-attention-Modul-ERA"><a href="#Extraction-with-Re-attention-Modul-ERA" class="headerlink" title="Extraction with Re-attention Modul (ERA)"></a>Extraction with Re-attention Modul (ERA)</h2><blockquote>
<p>re-combine effective feature 重新组合有效的特征</p>
</blockquote>
<p>两组通道和空间注意机制用来提取经过多层特征融合之后的深度语义信息。特征重新提取和权重分配更好地利用语义信息并防止细节被忽略。</p>
<img src="/Mask-TS-and-ODC-SA-net.md/era.png" class="" title="image-20240727102332424">
<p>further adjust and integrate its own feature information. This process generates a feature enhancement and combination graph that is more in line with the target. It allows different features to be combined into better features and can also realize the allocation of different feature emphasis degrees.</p>
<p>进一步调整和整合自己的特征信息。这个过程产生了一个更符合目标的特征增强和组合图。它允许不同的特征被组合成更好的特征，也可以实现不同特征强调程度的分配。</p>
<p>实现更好的拟合。</p>
<p>Output:<script type="math/tex">\widehat{Z_i}</script></p>
<h2 id="Shallow-Reverse-Attention-Mechanism-SRA"><a href="#Shallow-Reverse-Attention-Mechanism-SRA" class="headerlink" title="Shallow Reverse Attention Mechanism (SRA)"></a>Shallow Reverse Attention Mechanism (SRA)</h2><blockquote>
<p>enhance polyp edge with low level information 用低层次的信息增强息肉边缘</p>
</blockquote>
<p>渐层的编码输出有较多的边缘信息，指导RA（Reverse Attention）增强分割目标。</p>
<img src="/Mask-TS-and-ODC-SA-net.md/sra.png" class="" title="image-20240727105341404">
<p>problems:</p>
<p>the boundary between the background and the target is not obvious</p>
<p>solutions:</p>
<p>Inspired by ParNet, introduce RA (RA exploits the details of complementary regions by erasing the polyp regions that have been judged RA通过擦除已经判断过的息肉区域来利用互补区域的细节)</p>
<p>我们的网络使用最浅层的特征图来进行边界增强。</p>
<p>Output: <script type="math/tex">\hat{p_i}</script></p>
<h2 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h2><img src="/Mask-TS-and-ODC-SA-net.md/loss1.png" class="" title="image-20240727110943522">
<img src="/Mask-TS-and-ODC-SA-net.md/loss2.png" class="" title="image-20240727110950672">
<p>使用deep supervision <script type="math/tex">z_i</script>上采样到和<script type="math/tex">G</script>一样大，<script type="math/tex">\hat{p_i}</script>也一样。</p>
<h1 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h1><p><a href="https://blog.csdn.net/qq_39478403/article/details/121181904">【机器学习】详解 转置卷积 (Transpose Convolution)-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/yx868yx/article/details/107158692">增强感受野SPP、ASPP、RFB、PPM_spp模块的作用-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_39653948/article/details/104621249">markdown中的特殊字符、数学公式、图表等语法总结_markdown 制作流程图 有特殊符号-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_43964993/article/details/108360029#:~:text=加粗： %24pmb {字母}%24,加粗倾斜： %24boldsymbol {字母}%24">markdown公式中字母加粗_markdown 公式加粗-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/Ying_Xu/article/details/51240291">Latex所有常用数学符号整理_latex数学符号-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/tintinetmilou/article/details/81607721">Depthwise卷积与Pointwise卷积-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_37605642/article/details/135958384">通俗易懂理解注意力机制(Attention Mechanism)-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/oYeZhou/article/details/114288247">Pyramid Vision Transformer（PVT）: 纯Transformer设计，用于密集预测的通用backbone-CSDN博客</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Temperature scaling</title>
    <url>/Temperature-scaling.md/</url>
    <content><![CDATA[<h1 id="Temperature-scaling"><a href="#Temperature-scaling" class="headerlink" title="Temperature scaling"></a>Temperature scaling</h1><p>后验概率被应用在训练过程之后目的是学习一个重新校准的函数。为了达到这个目的，训练集的一部分被拿出作为校准集。重新校准函数适用于网络的输出（如logit向量），并产生一个改进的校准，该校准是在遗漏的校准集上学习的。<br><span id="more"></span><br>Temperature scaling是data-efficiency的accuracy-preserving方法，但是具有稍微不太好的expressive</p>
<p>Selective Scaling：</p>
<img src="/Temperature-scaling.md/image.png" class="" title="img">
<h1 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h1><p><a href="https://blog.csdn.net/m0_51233386/article/details/128414228">Ubuntu下tar命令使用详解 .tar解压、.tar压缩_ubuntu解压tar.gz-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/630739668">Logistic（逻辑斯蒂）函数浅谈 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/335765830">简介欧拉第一类积分：Beta函数 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/63184325">神经网络1：多层感知器-MLP - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/lingzhou33/article/details/87901365">语义分割的评价指标——IoU_语义分割iou-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33841176">CNN 入门讲解：什么是全连接层（Fully Connected Layer）? - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_37369201/article/details/109195257">python中assert的用法（简洁明了）_assert python-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/666048268">Expected Calibration Error (ECE) - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>校准</tag>
      </tags>
  </entry>
  <entry>
    <title>PVT encoder</title>
    <url>/PVT-encoder.md/</url>
    <content><![CDATA[<h1 id="PVT-encoder"><a href="#PVT-encoder" class="headerlink" title="PVT encoder"></a>PVT encoder</h1><p>use of transformer</p>
<p>For example, some works model the vision task as a dictionary lookup problem with learnable queries, and use the Transformer decoder as a task-specific head on top of the CNN backbone.</p>
<p>将视觉任务建模为一个具有可学习查询的字典查询问题，并将Transformer解码器作为CNN主干之上的特定任务头。</p>
<span id="more"></span>
<h2 id="ViT"><a href="#ViT" class="headerlink" title="ViT"></a>ViT</h2><p>拥有圆柱形的粗略images patches as input </p>
<p>shortcomings：</p>
<ol>
<li>输出特征图是单尺度而且底分辨率</li>
<li>计算花销大</li>
</ol>
<h2 id="PVT"><a href="#PVT" class="headerlink" title="PVT"></a>PVT</h2><p>a pure transformer backbone </p>
<p>advantages:</p>
<ol>
<li>细粒度(fine-grained)的图像patches 来学习高分辨率表征</li>
<li>引入一个逐渐减小的金字塔transformer的序列长度，减少计算量</li>
<li>引入空间降低注意力层(spatial-reduce attention layer)降低在学习高分辨率特征图的开销</li>
<li>产生全局感受野(global reception field)</li>
</ol>
<img src="/PVT-encoder.md/PVT.png" class="" title="image-20240812121219476">
<p>Feature Pyramid for Transformer</p>
<p>首先将输入特征图分为<script type="math/tex">\frac{H_i W_i}{P_i^2}</script>个patches，将每个patches展平之后并且将其映射到(projected to)<script type="math/tex">C_i</script>维度的embedding，再经过一个线性映射之后，embedded patches可以被视为<script type="math/tex">\frac{H_i-1}{P_i}\times \frac{W_i-1}{P_i} \times C_i</script></p>
<h2 id="SRA-？"><a href="#SRA-？" class="headerlink" title="SRA ？"></a>SRA ？</h2><img src="/PVT-encoder.md/sra.png" class="" title="image-20240812152215411">
<p>和MHA(multi-head attention)相似，receive Q K V,它在进行注意力机制之前减少了K和V的空间尺度，显著降低了计算和存贮</p>
<img src="/PVT-encoder.md/1.png" class="" title="image-20240814091739353">
<p>这里和原始transformer一样，只不过K和V先经过了一个空间降低操作。</p>
<img src="/PVT-encoder.md/2.png" class="" title="image-20240814091832785">
<img src="/PVT-encoder.md/3.png" class="" title="image-20240814091918147">
<p>hyper parameters:</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.192ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 969 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>: patch size of Stage <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.357ex" height="1.952ex" role="img" focusable="false" viewBox="0 -705 1042 862.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(748,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>: channel number of the output of Stage <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.28ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1008 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(714,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>: encoder layers number in Stage <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.457ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1086 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mi" transform="translate(792,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>: reduction ratio of the SRA in Stage <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.556ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1130 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(836,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>: head number of the SRA in Stage <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.409ex" height="1.895ex" role="img" focusable="false" viewBox="0 -680 1065 837.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mi" transform="translate(771,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>: expansion ratio of the feed-forward layer in Stage <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></p>
<p><strong>the rule of ResNet:</strong></p>
<ol>
<li><strong>use small output channel numbers in shallow stages</strong></li>
<li><strong>concentrate the major computation resource in intermediate stages.</strong></li>
<li><strong>with the growth of network depth, the hidden dimension gradually increases, and the output resolution progressively shrinks</strong></li>
<li><strong>the major computation resource is concentrated in Stage 3</strong></li>
</ol>
<p>the advantages over ViT:</p>
<ol>
<li>more flexible—can generate feature maps of different scales/channels in different stages</li>
<li>more versatile(通用)—can be easily plugged and played in most downstream task models</li>
<li>more friendly to computation/memory—can handle higher resolution feature maps or longer sequences</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><p><a href="https://blog.csdn.net/qq_38890412/article/details/120601834">全网最通俗易懂的 Self-Attention自注意力机制 讲解_self attention机制-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_42392454/article/details/122478544">狗都能看懂的Self-Attention讲解-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/video/BV15v411W78M/?spm_id_from=333.788">https://www.bilibili.com/video/BV15v411W78M/?spm_id_from=333.788</a></p>
<p><a href="https://blog.csdn.net/oYeZhou/article/details/114288247">Pyramid Vision Transformer（PVT）: 纯Transformer设计，用于密集预测的通用backbone-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_73179708/article/details/132516512">从零开始了解transformer的机制|第四章：FFN层的作用-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_51756104/article/details/127250190">对Transformer中FeedForward层的理解_feedforward层的作用-CSDN博客</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
  <entry>
    <title>U-Net</title>
    <url>/U-Net.md/</url>
    <content><![CDATA[<h1 id="U-Net"><a href="#U-Net" class="headerlink" title="U-Net"></a>U-Net</h1><p>​<img src="/U-Net.md/1.png" class="" title="img"><br>The architecture consists of a contracting path to capture context and a symmetric expanding path that enables precise localization.</p>
<p>该架构由一个捕捉上下文的收缩路径和一个实现精确定位的对称扩展路径组成</p>
 <span id="more"></span>
<p><strong>Hence, Ciresan et al.trained a network in a sliding-window setup to predict the class label of each pixel by providing a local region (patch) around that pixel as input.</strong></p>
<p><strong>This network can localize.</strong></p>
<p><strong>Two drawbacks: slow and redundant ,trade-off between localization accuracy and the use of context.</strong></p>
<p>The main idea in fully convolutional network is to supplement a usual contracting network by successive layers, where pooling operators are replaced by upsampling operators.</p>
<p>全卷积网络的主要思想是通过<strong>连续的层来补充通常的收缩网络，其中池化算子被上采样算子所取代。</strong></p>
<p>FCN的主要工作是将传统CNN后面的全连接层换成了卷积层，这样网络的输出将是热力图而非类别；同时，为解决卷积和池化导致图像尺寸的变小，使用上采样方式对图像尺寸进行恢复，并且提出一个跳级结构，让pool4和pool3之后的特征图于conv7之后的特征图相加，得到新的更加准确的分割图像。</p>
<p>这些layers增加了输出的分辨率。为了定位，通过收缩路径(conracting path)的高分辨率特征图和上采样的输出相结合，之后的连续卷积层可以来通过这些信息来学习更加精准的输出。</p>
<p><strong>对于上采样保留了很多的特征通道，这个网络没有全连接层，只有卷积层。</strong></p>
<p>只包含卷积就保证了seamless segmentation of arbitrarily large images by an overlap-tile strategy。通过重叠瓦片技术对任意大图形进行无缝分割。通过mirroring the input image.</p>
<p>To predict the pixels in the border region of the image, the missing context is extrapolated by mirroring the input image. This tiling strategy is important to apply the network to large images, since otherwise the resolution would be limited by the GPU memory.</p>
<p><strong>针对于数据增广，文章使用了弹性变换的方式，使得网络能够学习对这种变形的不变性，而不需要在注释的图像语料库中看到这些转换。</strong></p>
<p>对同类型的细胞的分离是很打的一个挑战。文章使用了weighted loss，针对不同地区进行不同的loss学习，让网络对边缘(border)进行学习，达到分离的效果。</p>
<h1 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a>网络结构：</h1><p>左边：contracting path(收缩路径) 右边：expansive path(扩展路径)</p>
<p>Contracting path :重复使用2个没有padding的3<em>3卷积，每个卷积之后包含ReLU和一个2</em>2最大池化（stride=2），同时，在每次下采样的过程中将通道数*2.</p>
<p>Expansive path : 2<em>2卷积进行上采样同时将通道数/2， 与收缩路径中相应裁剪的特征图相连接，两个3</em>3卷积每个都跟着一个ReLU。Cropping是重要的因为在卷积操作中会造成边缘像素的丢失。</p>
<p>最后一层有一个1*1的卷积将64个特征向量映射到每个所期待的类别。</p>
<p>总共有23层。</p>
<p>为了允许输出分割图的无缝平铺（见图2），重要的是选择输入平铺的大小，使所有2x2的最大池化操作都应用于一个具有偶数x和y大小的层。（换句话说，contracting path中经过卷积和ReLU之后的图像的x，y都是偶数）</p>
<h1 id="训练："><a href="#训练：" class="headerlink" title="训练："></a>训练：</h1><p>To minimize the overhead and make maximum use of the GPU memory, we favor large input tiles over a large batch size and hence reduce the batch to a single image.</p>
<p>为了最大限度地减少开销和最大限度地利用GPU内存，我们倾向于使用大的输入瓦片而不是大的批处理量，从而将批处理量减少到单一图像。（换句话说就是图像大，batch size小）</p>
<p>Accordingly we use a high momentum (0.99) such that a large number of the previously seen training samples determine the update in the current optimization step.</p>
<p>因此，我们使用一个高动量（0.99），这样大量的先前看到的训练样本决定了当前优化步骤中的更新。</p>
<p>能量函数(energy function)一开始在热力学中被定义，用于描述系统的能量值，当能量值达到最小时系统达到稳定状态。（换句话说就是优化函数）</p>
<p>energy function： pixel-wise soft-max + Cross entropy<br><img src="/U-Net.md/2.png" class="" title="img"></p>
<img src="/U-Net.md/3.png" class="" title="img">
<img src="/U-Net.md/4.png" class="" title="img">
<h1 id="Weighted-map："><a href="#Weighted-map：" class="headerlink" title="Weighted map："></a>Weighted map：</h1><img src="/U-Net.md/5.png" class="" title="img"> 
<img src="/U-Net.md/6.png" class="" title="img">
<p>需要有一个好的初始化a good initialization of the weights is extremely important</p>
<p>Ideally the initial weights should be adapted such that each feature map in the network has approximately unit variance. 理想情况下，初始权重应该被调整，使网络中的每个特征图具有近似的单位方差。</p>
<p>可以通过一个标准差为  的高斯分布得到。</p>
<h1 id="Data-augmentation"><a href="#Data-augmentation" class="headerlink" title="Data augmentation"></a>Data augmentation</h1><p>random elastic deformations is key concept..</p>
<p>We generate smooth deformations using random displacement vectors on a coarse 3 by 3 grid. The displacements are sampled from a Gaussian distribution with 10 pixels standard deviation. Per-pixel displacements are then computed using bicubic interpolation. Drop-out layers at the end of the contracting path perform further implicit data augmentation</p>
<p>我们在一个粗略的3乘3的网格上使用随机位移矢量生成平滑的变形。位移是从标准偏差为10像素的高斯分布中采样的。然后使用双三次插值计算每像素的位移。在收缩路径末端的剔除层进行进一步的隐性数据增强</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><p><a href="https://blog.csdn.net/qq_36717487/article/details/115368483">语义分割与实例分割的区别_实例分割和语义分割-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/lsb2002/article/details/132005658">机器学习：监督学习、无监督学习、半监督学习、强化学习-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_41731861/article/details/120511148">FCN（全卷积神经网络）详解-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/maliang_1993/article/details/82020596">仿射和弹性变换（affine and elastic transform）的python实现_图像增强弹性变换-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/u011622208/article/details/112566676">【数据增强】——弹性变形(Elastic Distortion)_数据增强随机弹性变换-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_36474809/article/details/87931260">Unet论文详解U-Net:Convolutional Networks for Biomedical Image Segmentation-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/gaoxueyi551/article/details/105238182">深度学习中的Momentum算法原理-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_43374104/article/details/106434440">梯度下降优化算法Momentum_momentum梯度下降法-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/hejunqing14/article/details/50057001">能量函数在神经网络中的意义_energy function-CSDN博客</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Diffusion model（后面有缘分再更新吧，没看很明白说实话）</title>
    <url>/diffusion_model.md/</url>
    <content><![CDATA[<p>东西有点多，有点看不过来<br><span id="more"></span></p>
<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><h2 id="它的过程其实很清晰，就是把一张全是噪声的图片生成一个新的，有意义的图片。"><a href="#它的过程其实很清晰，就是把一张全是噪声的图片生成一个新的，有意义的图片。" class="headerlink" title="它的过程其实很清晰，就是把一张全是噪声的图片生成一个新的，有意义的图片。"></a>它的过程其实很清晰，就是把一张全是噪声的图片生成一个新的，有意义的图片。</h2><h2 id="具体来说，是通过一个神经网络预测出一个噪声图，在原图上减去这个预测出来的图片，经过多轮的迭代之后得到一个新的，好看的，有意思的图片。"><a href="#具体来说，是通过一个神经网络预测出一个噪声图，在原图上减去这个预测出来的图片，经过多轮的迭代之后得到一个新的，好看的，有意思的图片。" class="headerlink" title="具体来说，是通过一个神经网络预测出一个噪声图，在原图上减去这个预测出来的图片，经过多轮的迭代之后得到一个新的，好看的，有意思的图片。"></a>具体来说，是通过一个神经网络预测出一个噪声图，在原图上减去这个预测出来的图片，经过多轮的迭代之后得到一个新的，好看的，有意思的图片。</h2><blockquote>
<p>鼠鼠只看了吴恩达的diffusion model和李宏毅的diffusion model，把链接都放在下面。</p>
<p>感觉吴恩达的视频没讲什么东西，只告诉我们怎么样进行训练，讲了一点最基础的理论，没有任何数学推导。感觉用处不算大。而且视频剪的emmm不太好评价</p>
<p><a href="https://www.bilibili.com/video/BV1mz4y1q7df/?vd_source=db8b493990184e57185c5ce1734577f2">爆火！这绝对是目前B站最新的diffusion教程，不愧是AI大佬，1小时弄清楚diffusion的工作原理，简直比刷剧还要爽！人工智能|机器学习|openAI_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV14c411J7f2/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db8b493990184e57185c5ce1734577f2">扩散模型 - Diffusion Model【李宏毅2023】_哔哩哔哩_bilibili</a></p>
<p><a href="https://speech.ee.ntu.edu.tw/~hylee/ml/ml2023-course-data/DDPM (v7">PowerPoint 簡報</a>.pdf) （李宏毅版本的pdf，只有后面的推导证明部分）</p>
<p>接下来主要根据李宏毅的视频进行记录（因为另一个根本不知道能记什么……)</p>
</blockquote>
<h1 id="二、训练过程"><a href="#二、训练过程" class="headerlink" title="二、训练过程"></a>二、训练过程</h1><h2 id="1、noise-predictor"><a href="#1、noise-predictor" class="headerlink" title="1、noise predictor"></a>1、noise predictor</h2><p>通过人为添加一些噪声到图片当中，得到有点噪声的图片。通过这些带有人为噪声的图片做为数据集，进行noise predictor的训练。</p>
<p>训练时，就让该模块对有噪声的图片进行预测得到噪声，跟我们人为添加的噪声进行比对，计算loss，逐渐收敛得到一个性能较好的模块。</p>
<p><strong>这个模块是人为创造数据集为其进行训练的，和鼠鼠之前了解过的dl不太一样</strong></p>
<h2 id="2、其余部分"><a href="#2、其余部分" class="headerlink" title="2、其余部分"></a>2、其余部分</h2><p>除了这个重要的noise predictor模块以外，还需要两个重要的参数</p>
<p>1、time step。它是来评估噪声程度的一个重要参数，调节模块对于现有图形的认识并且动态调整从噪声图中减去噪声的程度</p>
<p>2、文本参数。我们希望它朝我们期望的方向前进，就需要我们给它一些文本的描述，这也是需要给定的数据</p>
<h1 id="三、diffusion模型介绍"><a href="#三、diffusion模型介绍" class="headerlink" title="三、diffusion模型介绍"></a>三、diffusion模型介绍</h1><p>目前主流都是采用三个步骤来实现：</p>
<ol>
<li>text encoder。先对文本进行好的编码</li>
<li>generate model (经常是diffusion model或者autoregressive)。根据编码好的文字进行压缩图片的生成</li>
<li>decoder。通过上一步得到的压缩图片进行解码，得到最终经过整个流程之后的图片</li>
</ol>
<p><strong>三个部分通常是分开训练</strong></p>
<h2 id="text-encoder"><a href="#text-encoder" class="headerlink" title="text encoder"></a>text encoder</h2><p>FID评判指标：用于评判生成的图片和真实的图片之间的差距，检验生成的图片是否真实</p>
<p>通过一个已经训练好的cnn网络分别进行两张图像的表征，将两张图片的结果进行对比（前提是认为它们都符合高斯分布）</p>
<p>具体对比方式：计算两组分布之间的Frechet距离，所以两者越小越好</p>
<p>它需要sample出很多的图片才能进行测量，视频中提到的是10k张图片。</p>
<p>CLIP：简单说就是同时将text和image作为一个pair输入进去训练，看最后两者的距离是远还是近，主要作为text encoder</p>
<h2 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h2><p>优势：不需要成对的数据</p>
<ol>
<li><p>中间产物为缩小的图片</p>
<p>这种情况就很简单了，只需要训练一个网络能够放大图像就行（这个过程也有点唐，一个resize不就行了吗）</p>
</li>
<li><p>中间产物为latent representation</p>
</li>
</ol>
<p>​    需要训练一个auto encoder，把图像变成latent representation，然后再通过这个representation训练decoder。（感觉这个过程有点唐）</p>
<h2 id="generation-model"><a href="#generation-model" class="headerlink" title="generation model"></a>generation model</h2><h4 id="数据准备："><a href="#数据准备：" class="headerlink" title="数据准备："></a>数据准备：</h4><p>给定一张图片，先进行encoder，这个encoder得到的是latent representation</p>
<p>（这里感觉没讲明白，我不知道这里的encoder是什么东西，但是感觉不是text encoder）</p>
<p>得到latent representation之后，将噪声加在这个表征上面。</p>
<h4 id="训练predictor："><a href="#训练predictor：" class="headerlink" title="训练predictor："></a>训练predictor：</h4><p>把各个加上噪声的表征、step、text作为输入数据，放进predictor进行训练。</p>
<p>训练时要求得到一张加上噪声的表征，和放入训练的进行比对</p>
<h4 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h4><p>跟训练相反，把latent representation和text放进denoise模块中，重复多次直到得到满意的图片为止</p>
<p><br></p>
<h1 id="四、数学原理（概论率启动）"><a href="#四、数学原理（概论率启动）" class="headerlink" title="四、数学原理（概论率启动）"></a>四、数学原理（概论率启动）</h1><p>这里不知道为什么旁边的目录里多了一个无序列表的标识</p>
<h2 id="这里先贴上diffusion-model的training-algorithm"><a href="#这里先贴上diffusion-model的training-algorithm" class="headerlink" title="这里先贴上diffusion model的training algorithm"></a>这里先贴上diffusion model的training algorithm</h2><p><img src="https://picx.zhimg.com/v2-e964e3999951d0142bccbe6667e0bec7_1440w.png" alt="img"></p>
<p>来解释一下每一行是什么意思，非常标准的伪代码</p>
<p>第二行的<script type="math/tex">x_0</script>，指的是干净的数据。<script type="math/tex">x_0 \sim q(x_0)</script>是指从数据集中选出一张图片。我的理解是选出一个target</p>
<p>第三行的<script type="math/tex">t</script>, 指的是从<script type="math/tex">1-T</script>中sample出一个数，例如从1-1000中选出一个968</p>
<p>第四行的<script type="math/tex">\epsilon</script>, 指的是从均值为1 ，所有维度上的方差都为1的normal distribution中sample出一个noise，大小和<script type="math/tex">x_0</script>一样</p>
<p>第五行的公式</p>
<p>首先看<script type="math/tex">\left(\sqrt{\bar{\alpha_t}}\mathbf{x_0} + \sqrt{1-\bar{\alpha_t}}\boldsymbol{\epsilon}\right)</script> 其中，<script type="math/tex">\bar{\alpha_i}\,\,,i\in \left(1 - T \right)</script>是已经固定好的值，并且随着i的增大而减小。这个是通过计算得到的。</p>
<p>主要是为了平衡原图和噪声对于最后生成的图像的结果。</p>
<p>当t越大时，<script type="math/tex">\bar{\alpha_t}</script>越小，<script type="math/tex">1-\bar{\alpha_t}</script>越大，生成的叠加图中原图占比就小，噪声占比就大。</p>
<p>再看外面的<script type="math/tex">\boldsymbol{\epsilon_\theta}\left(  \sqrt{\bar{\alpha_t}}\mathbf{x_0} + \sqrt{1-\bar{\alpha_t}}\boldsymbol{\epsilon} ,t \right)</script> <u>这个是我们需要训练的noise predictor（划重点）</u>。 给一个生成的叠加图和时间t，放入该模块中，得到一个模块预测出来的noise</p>
<p>接下来就是让噪声真值减去预测出来的noise，得到一个loss，之后再通过梯度下降去优化算式直到收敛</p>
<h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><p>先别急到sample，先来学一学极大似然估计孩子们，链接放在下面的参考里了。</p>
<p>为什么要学？因为大家都这么干，来看看大家是怎么解决sample这个问题的。</p>
<p>用简单的话来说就是已知一个带参数的确定分布（一个带参数的函数），但是参数未知，需要得到那个参数。</p>
<p>因为该分布存在，所以，当参数取得最大值时，就更能确定分布，更加验证了该分布的合理性。（这一行有点绕，建议看一下视频）</p>
<p>要得到参数的最大值，将该函数先取对数（为的是降低幂次），求导，令其等于0，解出方程。</p>
<p>极大似然估计用人话讲就是这样。</p>
<p>来吧，来看看极大似然估计的用处</p>
<img src="/diffusion_model.md/1.png" class="" title="img">
<p>这里的<script type="math/tex">P_{data}(x)</script>是真实世界的数据，<script type="math/tex">x^1,x^2,...,x^m</script>是从真实世界中抽取出来的一些真实图片。</p>
<p>上面的<script type="math/tex">P_{\theta}(x)</script>可以认为是我们通常讲的似然函数。因为<script type="math/tex">P_{\theta}(x)</script>是我们预测出来的分布，它已经被模型预测出来了，所以它真实存在，可以作为似然函数。也可以理解为概率密度函数。</p>
<p>后面这个约等于用的妙，把<script type="math/tex">P_{data}(x)</script>和我们想要求的<script type="math/tex">P_{\theta}(x)</script>联系在一起。</p>
<p><strong>在等于<script type="math/tex">KL(P_{data}||P_{\theta})</script>这里，按道理应该是要等于<script type="math/tex">KL(P_{\theta}||P_{data})</script>，主要原因是它用了min，不再是之前的max，多了一个负号</strong></p>
<p>关于KL散度，熵等名词，在我另一个文章里面有写，链接在这里<a href="https://defyodd.github.io/香农熵，交叉熵和KL散度.md/#more">香农熵，交叉熵和KL散度 | This is defy_odd’s blog</a></p>
<p><strong>所以，在这当中，最大似然估计的值可以看成是最小KL散度</strong></p>
<p>又接着讲VAE了，靠，又要补了</p>
<h2 id="接下来是sampling的阶段"><a href="#接下来是sampling的阶段" class="headerlink" title="接下来是sampling的阶段"></a>接下来是sampling的阶段</h2><p><img src="https://pic4.zhimg.com/v2-66359434fb909922b327951e986fc99f_1440w.png" alt="img"></p>
<p><br></p>
<h1 id="PS：关于推理（Inference）和预测（Prediction）"><a href="#PS：关于推理（Inference）和预测（Prediction）" class="headerlink" title="PS：关于推理（Inference）和预测（Prediction）"></a>PS：关于推理（Inference）和预测（Prediction）</h1><p><strong>这里主要关注的点是推理模型和预测模型</strong></p>
<p>推理：更加关注于确定的数据，更重要的是<strong>模型的可解释性</strong>，这是能够进行推理的重要指标。能够让外行理解模型产生预测的过程</p>
<p>预测：更加关注于通过概率得到的结果，更加依赖以参数估计相关的置信度(感觉是概率论里面的东西)</p>
<p><strong>通常说的推理和预测，一般是训练结束输入新的数据进行处理，二者通常可以等价</strong></p>
<p><br></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.datascienceblog.net/post/commentary/inference-vs-prediction/">Inference vs Prediction - Data Science Blog: Understand. Implement. Succed.</a> (这全英的看的我难受死了)</p>
<p><a href="https://blog.csdn.net/huiyuanliyan/article/details/87900550">深度学习的宏观框架——训练（training）和推理（inference）及其应用场景_深度学习中inference部分是-CSDN博客</a></p>
<p><a href="https://pytorch.ac.cn/docs/stable/generated/torch.cumsum.html">torch.cumsum — PyTorch 2.6 文档 - PyTorch 深度学习库</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/674001640">扩散模型中的Noise Scheduler - 知乎</a> （这个知乎写的挺好的，但是感觉概论率的东西有点多看不太明白）</p>
<p><a href="https://www.bilibili.com/video/av632597949?vd_source=db8b493990184e57185c5ce1734577f2&amp;spm_id_from=333.788.player.switch">似然估计不会做？这个视频让你从头通透到脚趾！_哔哩哔哩_bilibili</a> （最大似然估计都忘记了）</p>
<p><a href="https://blog.csdn.net/poisonchry/article/details/119027117">概率论基础 —— 8.数学期望、方差、协方差_期望和方差-CSDN博客</a> （看了一眼期望的连续是咋样的）</p>
<p><a href="https://bohrium.dp.tech/notebooks/74114486918">AI+分子模拟：从 Score Matching 到 Diffusion Model，从瑞士卷到丁烷 | Bohrium-玻尔科研空间站</a> （应某人要求，把这个最开始的链接放上来，但是我真的没参考里面的东西，看不懂啊（捂脸））</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>sql急救</title>
    <url>/sql%E6%80%A5%E6%95%91.md/</url>
    <content><![CDATA[<p>虽然最后没用上.jpg<br><span id="more"></span></p>
<h3 id="7-分数排名"><a href="#7-分数排名" class="headerlink" title="#7 分数排名"></a>#7 分数排名</h3><hr>
<p>编写一个 sql 查询来实现分数排名。</p>
<p>如果两个分数相同，则两个分数排名（rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">3.50</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">3.65</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> <span class="number">4.00</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">3.85</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> <span class="number">4.00</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6</span>  <span class="operator">|</span> <span class="number">3.65</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br></pre></td></tr></table></figure>
<p>例如，根据上述给定的 scores 表，你的查询应该返回（按分数从高到低排列）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------+------+</span></span><br><span class="line"><span class="operator">|</span> score <span class="operator">|</span> rank <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4.00</span>  <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4.00</span>  <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.85</span>  <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.65</span>  <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.65</span>  <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.50</span>  <span class="operator">|</span> <span class="number">4</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+</span></span><br></pre></td></tr></table></figure>
<p><strong>重要提示</strong>：对于 mysql 解决方案，如果要转义用作列名的保留字，可以在 关键字之前和 之后使用撇号。例如 <code>rank</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><hr>
<p>最后的结果包含两个部分，第一部分是 降序排列的分数，第二部分是每个分数对应的排名。</p>
<p>第一部分不难写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.score <span class="keyword">as</span> scorefrom scores aorder <span class="keyword">by</span> a.score <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p>比较难的是第二部分。假设现在给你一个分数x，如何算出它的排名rank呢？<br>我们可以先提取出大于等于x的 所有分数集 合h，将h去重后的元素个数就是x的排名。比如你考了99分，但最高的就只有99分，那么去重之后集合h里就只有99一个元素 ，个数为1， 因此你的rank为1。<br>先提取集合h：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.score <span class="keyword">from</span> scores b <span class="keyword">where</span> b.score <span class="operator">&gt;=</span> x;</span><br></pre></td></tr></table></figure>
<p>我们要的是集合h去重之后 的元素个数，因此升级为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> b.score) <span class="keyword">from</span> scores b <span class="keyword">where</span> b.score <span class="operator">&gt;=</span> x <span class="keyword">as</span> rank;</span><br></pre></td></tr></table></figure>
<p>而从结果的角度来看，第二部分的rank是对应第一部分的分数来的，所以这里的x就是上面的a.score，把两部分结合在一起为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.score <span class="keyword">as</span> score,</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span> b.score)</span><br><span class="line">    <span class="keyword">from</span> scores b</span><br><span class="line">    <span class="keyword">where</span>  b.score<span class="operator">&gt;=</span>a.score </span><br><span class="line">) <span class="keyword">as</span> <span class="string">&#x27;rank&#x27;</span></span><br><span class="line"><span class="keyword">from</span> scores a </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.score <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<h3 id="10-连续出现的数字"><a href="#10-连续出现的数字" class="headerlink" title="#10 连续出现的数字"></a>#10 连续出现的数字</h3><hr>
<p>表：logss</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">column</span> name <span class="operator">|</span> type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> num         <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br></pre></td></tr></table></figure>
<p>id 是这个表的主键。</p>
<p>编写一个 sql 查询，查找所有至少连续出现三次的数字。</p>
<p>返回的结果表中的数据可以按 任意顺序 排列。</p>
<p>查询结果格式如下面的例子所示：</p>
<p>logss 表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> num <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6</span>  <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7</span>  <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+</span></span><br></pre></td></tr></table></figure>
<p>result 表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> consecutivenums <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure>
<p>1 是唯一连续出现至少三次的数字。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">DISTINCT</span> l1.num <span class="keyword">as</span> consecutivenums</span><br><span class="line"><span class="keyword">from</span> logss l1,logss l2,logss l3</span><br><span class="line"><span class="keyword">where</span> l1.id<span class="operator">=</span>l2.id<span class="number">-1</span> <span class="keyword">and</span> l1.id<span class="operator">=</span>l3.id<span class="number">-2</span> </span><br><span class="line"><span class="keyword">and</span> l1.num<span class="operator">=</span>l2.num <span class="keyword">and</span> l1.num<span class="operator">=</span>l3.num;</span><br></pre></td></tr></table></figure>
<h3 id="11-两人之间的通话次数"><a href="#11-两人之间的通话次数" class="headerlink" title="#11 两人之间的通话次数"></a>#11 两人之间的通话次数</h3><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表： calls</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">column</span> name <span class="operator">|</span> type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> from_id     <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> to_id       <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> duration    <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">该表没有主键，可能存在重复项。</span><br><span class="line">该表包 含 from_id 与 to_id 间的一次电话的时长。from_id <span class="operator">!=</span> to_id</span><br><span class="line"></span><br><span class="line">编写 <span class="keyword">sql</span> 语句，查询每一对用户 (person1, person2) 之间的通话次数和通话总时长，其中 person1 <span class="operator">&lt;</span> person2 。</span><br><span class="line">以任意顺序返回结果表。查询结果格式如下示例所示：</span><br><span class="line">calls 表：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> from_id <span class="operator">|</span> to_id <span class="operator">|</span> duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span> <span class="number">59</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>       <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> <span class="number">11</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> <span class="number">20</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>       <span class="operator">|</span> <span class="number">4</span>     <span class="operator">|</span> <span class="number">100</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>       <span class="operator">|</span> <span class="number">4</span>     <span class="operator">|</span> <span class="number">200</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>       <span class="operator">|</span> <span class="number">4</span>     <span class="operator">|</span> <span class="number">200</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> <span class="number">499</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-------+----------+</span></span><br><span class="line">结果表 ：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> person1 <span class="operator">|</span> person2 <span class="operator">|</span> call_count <span class="operator">|</span> total_duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span> <span class="number">2</span>       <span class="operator">|</span> <span class="number">2</span>          <span class="operator">|</span> <span class="number">70</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>       <span class="operator">|</span> <span class="number">3</span>       <span class="operator">|</span> <span class="number">1</span>          <span class="operator">|</span> <span class="number">20</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>       <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="number">4</span>          <span class="operator">|</span> <span class="number">999</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+------------+----------------+</span></span><br><span class="line">用户 <span class="number">1</span> 和 <span class="number">2</span> 打过 <span class="number">2</span> 次电话，总时长为 <span class="number">70</span> (<span class="number">59</span> <span class="operator">+</span> <span class="number">11</span>)。</span><br><span class="line">用户 <span class="number">1</span> 和 <span class="number">3</span> 打过 <span class="number">1</span> 次电话，总时长为 <span class="number">20</span>。</span><br><span class="line">用户 <span class="number">3</span> 和 <span class="number">4</span> 打过 <span class="number">4</span> 次电话，总时长为 <span class="number">999</span> (<span class="number">100</span> <span class="operator">+</span> <span class="number">200</span> <span class="operator">+</span> <span class="number">200</span> <span class="operator">+</span> <span class="number">499</span>)。</span><br></pre></td></tr></table></figure>
<h3 id="题解：if"><a href="#题解：if" class="headerlink" title="题解：if"></a>题解：if</h3><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tmp.t1 person1,tmp.t2 person2,<span class="built_in">count</span>(<span class="operator">*</span>) call_count,<span class="built_in">sum</span>(duration) total_duration</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> if(from_id<span class="operator">&gt;</span>to_id,to_id,from_id) t1,</span><br><span class="line">           if(from_id<span class="operator">&gt;</span>to_id,from_id,to_id) t2,</span><br><span class="line">    	   duration <span class="keyword">from</span> calls</span><br><span class="line">) <span class="keyword">as</span> tmp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> tmp.t1,tmp.t2;</span><br></pre></td></tr></table></figure>
<h3 id="39-查找拥有有效邮箱的用户"><a href="#39-查找拥有有效邮箱的用户" class="headerlink" title="#39 查找拥有有效邮箱的用户"></a>#39 查找拥有有效邮箱的用户</h3><hr>
<p>邮箱表： email</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+---------+| column name   | type    |+---------------+---------+| user_id       | int     || name          | varchar || mail          | varchar | +---------------+---------+user_id （用户 id）是该表的主键。这个表包含用户在某网站上注册的信息。有些邮箱是无效的。</span><br></pre></td></tr></table></figure>
<p>写一条 sql 语句，查询拥有有效邮箱的用户。</p>
<p>有效的邮箱包含符合下列条件的前缀名和域名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前缀名是包含字母（大写或小写）、数字、下划线 &#x27;_&#x27;、句点 &#x27;.&#x27; 和/或横杠 &#x27;-&#x27; 的字符串。前缀名必须以字母开头。   域名是 &#x27;@leetcode.com&#x27; 。</span><br></pre></td></tr></table></figure>
<p>按 任意顺序返回结果表。</p>
<p>查询格式如下所示：email</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">| user_id | name      | mail                    |</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">| 1       | winston   | winston@leetcode.com    |</span><br><span class="line">| 2       | jonathan  | jonathanisgreat         |</span><br><span class="line">| 3       | annabelle | bella-@leetcode.com     |</span><br><span class="line">| 4       | sally     | sally.come@leetcode.com |</span><br><span class="line">| 5       | marwan    | quarz#2020@leetcode.com |</span><br><span class="line">| 6       | david     | david69@gmail.com       |</span><br><span class="line">| 7       | shapiro   | .shapo@leetcode.com     |</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">结果表：</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">| user_id | name      | mail                    |</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">| 1       | winston   | winston@leetcode.com    |</span><br><span class="line">| 3       | annabelle | bella-@leetcode.com     |</span><br><span class="line">| 4       | sally     | sally.come@leetcode.com |</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">2 号用户的邮箱没有域名。</span><br><span class="line">5 号用户的邮箱包含非法字符 #。</span><br><span class="line">6 号用户的邮箱的域名不是 leetcode。</span><br><span class="line">7 号用户的邮箱以 句点（.）开头。</span><br></pre></td></tr></table></figure>
<h3 id="题解：regexp"><a href="#题解：regexp" class="headerlink" title="题解：regexp"></a>题解：regexp</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^ 表示以后面的字符为开头  [] 表示括号内任意字符</span><br></pre></td></tr></table></figure>
<ul>
<li><p>表示连续</p>
<ul>
<li><p>表示重复前面任意字符任意次数</p>
<p>\ 用来转义后面的特殊字符，以表示字符原本的样子，而不是将其作为特殊字符使用<br>$ 表示以前面的字符为结尾</p>
</li>
</ul>
</li>
</ul>
<p>1.前缀名以字母开头：^[a-zA-Z]<br>2.前缀名包含字母（大写或小写）、数字、下划线<em>、句点. 和 或 横杠-：[a-zA-Z0-9\</em>.-]*</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> email</span><br><span class="line"><span class="keyword">where</span> mail regexp <span class="string">&#x27;^[a-zA-Z][a-zA-Z0-9\_\.\-]*@leetcode.com$&#x27;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>u-kan</title>
    <url>/u-kan.md/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/jarodyv/article/details/138751803">深入理解 Kolmogorov–Arnold Networks (KAN)_kan: kolmogorov–arnold networks-CSDN博客</a></p>
<p><a href="https://www.zhihu.com/question/654782350">(5 封私信 / 14 条消息) 如何评价神经网络架构KAN，是否有潜力取代MLP？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/fg13821267836/article/details/93405572">多层感知机（MLP）简介-CSDN博客</a></p>
<p>MLP说白了就是最简单的<script type="math/tex">f(w_i×x+b_i)+softmax</script>.</p>
<p><a href="https://blog.csdn.net/qq_46703208/article/details/130539464">深度学习中的token_深度学习token-CSDN博客</a></p>
<p>token:最小的单元。在nlp领域，就是一个单词。cv领域，在vit中就是16x16的patch</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>论文学习</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode(持续更新ing)</title>
    <url>/leetcode.md/</url>
    <content><![CDATA[<h1 id="Leetcode-704-二分查找-24-12-13"><a href="#Leetcode-704-二分查找-24-12-13" class="headerlink" title="Leetcode  704. 二分查找 24.12.13"></a>Leetcode  <a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a> 24.12.13</h1><h2 id="梦开始的地方"><a href="#梦开始的地方" class="headerlink" title="梦开始的地方"></a>梦开始的地方</h2><span id="more"></span>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right){</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[middle]&lt;target){</span><br><span class="line">                left=middle<span class="number">+1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle]&gt;target){</span><br><span class="line">                right=middle<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-27-移除元素-24-12-15"><a href="#Leetcode-27-移除元素-24-12-15" class="headerlink" title="Leetcode 27. 移除元素 24.12.15"></a>Leetcode <a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a> 24.12.15</h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p>
<ul>
<li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>
<li>返回 <code>k</code>。</li>
</ul>
<p><strong>用户评测：</strong></p>
<p>评测机将使用以下代码测试您的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int val = ...; // 要移除的值</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的预期答案。</span><br><span class="line">                            // 它以不等于 val 的值排序。</span><br><span class="line"></span><br><span class="line">int k = removeElement(nums, val); // 调用你的实现</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">sort(nums, 0, k); // 排序 nums 的前 k 个元素</span><br><span class="line">for (int i = 0; i &lt; actualLength; i++) {</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h2 id="题解：-双指针"><a href="#题解：-双指针" class="headerlink" title="题解： 双指针"></a>题解： 双指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast=<span class="number">0</span>;fast&lt;nums.<span class="built_in">size</span>();fast++){</span><br><span class="line">            <span class="keyword">if</span> (nums[fast]!=val){</span><br><span class="line">                nums[slow++]=nums[fast];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-977-有序数组的平方-24-12-15"><a href="#Leetcode-977-有序数组的平方-24-12-15" class="headerlink" title="Leetcode 977. 有序数组的平方 24.12.15"></a>Leetcode <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a> 24.12.15</h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li>
</ul>
<h2 id="题解：双指针，注意初始化vector长度"><a href="#题解：双指针，注意初始化vector长度" class="headerlink" title="题解：双指针，注意初始化vector长度"></a>题解：双指针，注意初始化vector长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> t=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;=j;){</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">abs</span>(nums[i]) &gt; <span class="built_in">abs</span>(nums[j]) ) {</span><br><span class="line">                res[t]=nums[i]*nums[i];</span><br><span class="line">                <span class="comment">//res.insert(res.begin(),nums[i]*nums[i]);</span></span><br><span class="line">                i++;t--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                res[t]=nums[j]*nums[j];</span><br><span class="line">                <span class="comment">//res.insert(res.begin(),nums[j]*nums[j]);</span></span><br><span class="line">                j--;t--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-209-长度最小的子数组-24-12-17"><a href="#Leetcode-209-长度最小的子数组-24-12-17" class="headerlink" title="Leetcode 209. 长度最小的子数组 24.12.17"></a>Leetcode <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a> 24.12.17</h1><h2 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p>
<p><strong>子数组</strong></p>
<p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<h2 id="题解：滑动窗口"><a href="#题解：滑动窗口" class="headerlink" title="题解：滑动窗口"></a>题解：滑动窗口</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;<span class="comment">//起始</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">99999999</span>;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//j为终止下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++){</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target){</span><br><span class="line">                len=j-i<span class="number">+1</span>;</span><br><span class="line">                res=<span class="built_in">min</span>(res,len);</span><br><span class="line">                sum-=nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum&lt;target&amp;&amp;res==<span class="number">99999999</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-59-螺旋矩阵-II-24-12-17"><a href="#Leetcode-59-螺旋矩阵-II-24-12-17" class="headerlink" title="Leetcode 59. 螺旋矩阵 II  24.12.17"></a>Leetcode <a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II </a> 24.12.17</h1><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
<h2 id="题解：模拟，注意创建二维数组方式"><a href="#题解：模拟，注意创建二维数组方式" class="headerlink" title="题解：模拟，注意创建二维数组方式"></a>题解：模拟，注意创建二维数组方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) {</span><br><span class="line">        <span class="comment">//采用左闭右开</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> startx=<span class="number">0</span>;<span class="type">int</span> starty=<span class="number">0</span>;<span class="comment">//起始位置</span></span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>;<span class="comment">//右开</span></span><br><span class="line">        <span class="type">int</span> t=n/<span class="number">2</span>;<span class="comment">//转几圈</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t){</span><br><span class="line">            <span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (j=starty;j&lt;n-offset;j++){</span><br><span class="line">                matrix[startx][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (i=startx;i&lt;n-offset;i++){</span><br><span class="line">                matrix[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">for</span> (;j&gt;starty;j--){</span><br><span class="line">                matrix[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">for</span> (;i&gt;startx;i--){</span><br><span class="line">                matrix[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            startx++;starty++;offset++;</span><br><span class="line">            t--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">1</span>){</span><br><span class="line">            matrix[n/<span class="number">2</span>][n/<span class="number">2</span>]=count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-203-移除链表元素"><a href="#Leetcode-203-移除链表元素" class="headerlink" title="Leetcode 203. 移除链表元素"></a>Leetcode <a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><h2 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<h2 id="题解：虚拟头节点"><a href="#题解：虚拟头节点" class="headerlink" title="题解：虚拟头节点"></a>题解：虚拟头节点</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//方法一：虚拟头节点，这种方法比较正常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListNode* dhead= <span class="keyword">new</span> ListNode;</span><br><span class="line">        dhead-&gt;next=head;</span><br><span class="line">        ListNode* cur=dhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val==val){</span><br><span class="line">                cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dhead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：不创建虚拟头节点，直接使用第一个元素作为head，需要多处理一下删除头节点的情况，相对复杂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="literal">NULL</span>&amp;&amp;head-&gt;val==val){</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">if</span> (cur==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>&amp;&amp;cur!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val==val){</span><br><span class="line">                cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-707-设计链表-1-12"><a href="#Leetcode-707-设计链表-1-12" class="headerlink" title="Leetcode 707. 设计链表 1.12"></a>Leetcode <a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 </a>1.12</h1><h2 id="题面-5"><a href="#题面-5" class="headerlink" title="题面"></a>题面</h2><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]</span><br><span class="line">[[], [1], [3], [1, 2], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, 2, null, 3]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = new MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(1);</span><br><span class="line">myLinkedList.addAtTail(3);</span><br><span class="line">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 2</span><br><span class="line">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= index, val &lt;= 1000</code></li>
<li>请不要使用内置的 LinkedList 库。</li>
<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>
</ul>
<h2 id="题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head-gt-next开始"><a href="#题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head-gt-next开始" class="headerlink" title="题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head->next开始"></a>题解：挺红的，这给一个样例改一次bug，改了有半小时还不止，关注addAtTail，addAtIndex，deleteAtIndex函数，它们都从head开始遍历，不从head-&gt;next开始</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目当中的ListNode的结构是这样的</span></span><br><span class="line"><span class="comment">// struct ListNode{</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     ListNode *next;</span></span><br><span class="line"><span class="comment">// };</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() {</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        head-&gt;val=<span class="number">0</span>;</span><br><span class="line">        head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 第一个元素的下标是0，从虚拟头节点的下一个开始向后遍历</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index--){</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListNode *t=<span class="keyword">new</span> ListNode;</span><br><span class="line">        t-&gt;val=val;</span><br><span class="line">        t-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next=t;    </span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            cur= cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;next=t;</span><br><span class="line">        t-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        t-&gt;val=val;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index&gt;size) <span class="keyword">return</span> ;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="comment">//index-=1;</span></span><br><span class="line">        <span class="keyword">while</span> (index&gt;<span class="number">0</span>){</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        }</span><br><span class="line">        t-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=t;</span><br><span class="line">        t-&gt;val=val;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span>||index&gt;size<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        ListNode *cur=head;</span><br><span class="line">        <span class="comment">//index-=1;</span></span><br><span class="line">        <span class="keyword">while</span> (index&gt;<span class="number">0</span>){</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        size--;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-206-反转链表-1-13"><a href="#Leetcode-206-反转链表-1-13" class="headerlink" title="Leetcode 206. 反转链表 1.13"></a>Leetcode <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 </a>1.13</h1><h2 id="题面-6"><a href="#题面-6" class="headerlink" title="题面"></a>题面</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h2 id="题解-双指针解法-就是一个cur一个pre，让cur往前指。"><a href="#题解-双指针解法-就是一个cur一个pre，让cur往前指。" class="headerlink" title="题解 双指针解法 就是一个cur一个pre，让cur往前指。"></a>题解 双指针解法 就是一个cur一个pre，让cur往前指。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *cur=head;</span><br><span class="line">        ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur){</span><br><span class="line">            ListNode *t=cur-&gt;next;</span><br><span class="line">            cur-&gt;next= pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=t;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="解法二：递归，其实就是简略版本的双指针"><a href="#解法二：递归，其实就是简略版本的双指针" class="headerlink" title="解法二：递归，其实就是简略版本的双指针"></a>解法二：递归，其实就是简略版本的双指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *pre,ListNode *cur)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (cur==<span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    ListNode *t= cur-&gt;next;</span><br><span class="line">    cur-&gt;next=pre;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverse</span>(cur,t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>,head);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-24-两两交换链表中的节点-1-14"><a href="#leetcode-24-两两交换链表中的节点-1-14" class="headerlink" title="leetcode 24. 两两交换链表中的节点 1.14"></a>leetcode <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 </a>1.14</h1><h2 id="题面-7"><a href="#题面-7" class="headerlink" title="题面"></a>题面</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur-gt-next-NULL-amp-amp-cur-gt-next-gt-next-NULL。两者要一起，最后return的是dummyhead-gt-next。"><a href="#题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur-gt-next-NULL-amp-amp-cur-gt-next-gt-next-NULL。两者要一起，最后return的是dummyhead-gt-next。" class="headerlink" title="题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur->next!=NULL&&cur->next->next!=NULL。两者要一起，最后return的是dummyhead->next。"></a>题解：交换的是节点，需要有一个虚拟头节点，让cur指针去操作后面的两个节点，循环条件是要cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;next!=NULL。两者要一起，最后return的是dummyhead-&gt;next。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            ListNode *t = cur-&gt;next;</span><br><span class="line">            ListNode *t1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = t;</span><br><span class="line">            t-&gt;next = t1;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-19-删除链表的倒数第-N-个结点-1-18"><a href="#leetcode-19-删除链表的倒数第-N-个结点-1-18" class="headerlink" title="leetcode 19. 删除链表的倒数第 N 个结点 1.18"></a>leetcode <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a> 1.18</h1><h2 id="题面-8"><a href="#题面-8" class="headerlink" title="题面"></a>题面</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h2 id="题解：经典双指针（fast-slow）-dummyhead-先移动fast指针，到相距n-1的位置，之后再同时移动fast和slow"><a href="#题解：经典双指针（fast-slow）-dummyhead-先移动fast指针，到相距n-1的位置，之后再同时移动fast和slow" class="headerlink" title="题解：经典双指针（fast,slow）+dummyhead,先移动fast指针，到相距n+1的位置，之后再同时移动fast和slow"></a>题解：经典双指针（fast,slow）+dummyhead,先移动fast指针，到相距n+1的位置，之后再同时移动fast和slow</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        dummyhead-&gt;next=head;</span><br><span class="line">        ListNode *fast = dummyhead;</span><br><span class="line">        ListNode *slow = dummyhead;</span><br><span class="line">        <span class="comment">//注意fast要再往前移一位，先移动fast指针，之后再移动slow指针</span></span><br><span class="line">        <span class="comment">//这样刚好slow指针可以移动到需要被删除的节点的前一个</span></span><br><span class="line">        n++; </span><br><span class="line">        <span class="keyword">while</span> (n--&amp;&amp;fast!=<span class="literal">NULL</span>){</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">NULL</span>){</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode142-环形链表-II-1-19"><a href="#leetcode142-环形链表-II-1-19" class="headerlink" title="leetcode142. 环形链表 II 1.19"></a>leetcode<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a> 1.19</h1><h2 id="题面-9"><a href="#题面-9" class="headerlink" title="题面"></a>题面</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<h2 id="思路：karl-is-all-you-need"><a href="#思路：karl-is-all-you-need" class="headerlink" title="思路：karl is all you need."></a>思路：karl is all you need.</h2><h2 id="双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。"><a href="#双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。" class="headerlink" title="双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。"></a>双指针，一个走的快一个走的慢，快的一次走两格，慢的一次走一格。如果有环的话，一定会在环内相遇。确定进入环的节点，需要使用一个公式推导。</h2><img src="/leetcode.md/142.png" class="" title="img">
<p>假设快指针走两格，慢指针走一格。</p>
<p>在A点相遇时，快指针已经走过了<script type="math/tex">x+y+n(y+z)</script>的路程</p>
<p>慢指针走过了<script type="math/tex">x+y</script>的路程。至于为什么不需要加上<script type="math/tex">k(z+y)</script>，主要是因为，只要慢指针进入之后，快指针一定只需要一圈之内就能追上，因为速度是慢指针的两倍。</p>
<p><strong>相遇是判断是否有环的重要判断条件</strong>。</p>
<p>然后就开始了快乐的公式推导过程：</p>
<p>因为我们假设的是快指针是慢指针速度的两倍，所以</p>
<script type="math/tex; mode=display">
2(x+y) = x+y+n(y+z)</script><p>因为我们想要得到的是<script type="math/tex">x</script> ,所以</p>
<script type="math/tex; mode=display">
x = n(y+z)-y</script><p><strong>接下来一步很关键，很厉害</strong></p>
<script type="math/tex; mode=display">
x = (n-1)(y+z)+z</script><p>这说明，在<script type="math/tex">n=1</script>的时候，<script type="math/tex">x=z</script>。如果<script type="math/tex">n>1</script>的时候，只不过是快指针在环里面多走了<script type="math/tex">n-1</script>圈。和最后相遇是没有差别的。</p>
<p><strong>其实，<script type="math/tex">x=z</script>的意义在于，我从起点向进入环的点走和从相遇点到进入点的距离是一样的。这个是重要的寻找进入点的条件。就在相遇之后，利用这个条件，让两个点都向进入点走。两个相遇的时候就是进入点</strong>.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow){</span><br><span class="line">                ListNode *index1 = fast;</span><br><span class="line">                ListNode *index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1!=index2){</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode242-有效的字母异位词-1-20"><a href="#leetcode242-有效的字母异位词-1-20" class="headerlink" title="leetcode242. 有效的字母异位词 1.20"></a>leetcode<a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a> 1.20</h1><h2 id="题面-10"><a href="#题面-10" class="headerlink" title="题面"></a>题面</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = "anagram", t = "nagaram"</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = "rat", t = "car"</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>
<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul>
<p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h2 id="题解：之前上课的时候遇到过这样的题目"><a href="#题解：之前上课的时候遇到过这样的题目" class="headerlink" title="题解：之前上课的时候遇到过这样的题目"></a>题解：之前上课的时候遇到过这样的题目</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="type">int</span> arr [<span class="number">26</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++){</span><br><span class="line">            arr[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;t.<span class="built_in">size</span>();i++){</span><br><span class="line">            arr[t[i]-<span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++){</span><br><span class="line">            <span class="keyword">if</span> (arr[i]!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode349-两个数组的交集-1-20"><a href="#leetcode349-两个数组的交集-1-20" class="headerlink" title="leetcode349. 两个数组的交集 1.20"></a>leetcode<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 </a>1.20</h1><h2 id="题面-11"><a href="#题面-11" class="headerlink" title="题面"></a>题面</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的</em> <em>交集</em></p>
<p>输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
<h2 id="题解：使用unordered-set进行操作，并且注意将vector转化成set时候的代码。使用-find函数时，没找到会返回-end-。"><a href="#题解：使用unordered-set进行操作，并且注意将vector转化成set时候的代码。使用-find函数时，没找到会返回-end-。" class="headerlink" title="题解：使用unordered_set进行操作，并且注意将vector转化成set时候的代码。使用.find函数时，没找到会返回.end()。"></a>题解：使用unordered_set进行操作，并且注意将vector转化成set时候的代码。使用.find函数时，没找到会返回.end()。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">num_set</span><span class="params">(nums<span class="number">1.</span>begin(),nums<span class="number">1.</span>end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums<span class="number">2.</span><span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">if</span> (num_set.<span class="built_in">find</span>(nums2[i])!=num_set.<span class="built_in">end</span>()){</span><br><span class="line">                res.<span class="built_in">insert</span>(nums2[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.programmercarl.com/0349.两个数组的交集.html#思路">代码随想录</a></p>
<p><a href="https://blog.csdn.net/qq_29931565/article/details/124511606">【C++】unordered_set中find()用法及代码示例_c++ unorderset的find-CSDN博客</a></p>
<h1 id="leetcode-1-两数之和-1-21"><a href="#leetcode-1-两数之和-1-21" class="headerlink" title="leetcode 1. 两数之和 1.21"></a>leetcode <a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a> 1.21</h1><h2 id="这是很多人梦开始的地方（不是很能理解这道题是容易题）"><a href="#这是很多人梦开始的地方（不是很能理解这道题是容易题）" class="headerlink" title="这是很多人梦开始的地方（不是很能理解这道题是容易题）"></a>这是很多人梦开始的地方（不是很能理解这道题是容易题）</h2><h2 id="题面-12"><a href="#题面-12" class="headerlink" title="题面"></a>题面</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<h2 id="题解：重点是使用unordered-map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums-i-得到。"><a href="#题解：重点是使用unordered-map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums-i-得到。" class="headerlink" title="题解：重点是使用unordered_map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums[i]得到。"></a>题解：重点是使用unordered_map去存取那些已经遍历过的数。因为只要两数之和，遍历过的数可以放在map里面，而且巧妙的是，由于只需要两个数，另一个数可以直接由target-nums[i]得到。</h2><h3 id="1、双重循环深似海，皆为纸上谈兵之事"><a href="#1、双重循环深似海，皆为纸上谈兵之事" class="headerlink" title="1、双重循环深似海，皆为纸上谈兵之事"></a>1、双重循环深似海，皆为纸上谈兵之事</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++){</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;nums.<span class="built_in">size</span>();j++){</span><br><span class="line">                <span class="keyword">if</span> (nums[i]+nums[j]==target){</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="2、一招map走天下，全是Carl下人间"><a href="#2、一招map走天下，全是Carl下人间" class="headerlink" title="2、一招map走天下，全是Carl下人间"></a>2、一招map走天下，全是Carl下人间</h3><h3 id="梦开始的地方，Leetcode：1-两数之和，学透哈希表，map使用有技巧！-哔哩哔哩-bilibili"><a href="#梦开始的地方，Leetcode：1-两数之和，学透哈希表，map使用有技巧！-哔哩哔哩-bilibili" class="headerlink" title="梦开始的地方，Leetcode：1.两数之和，学透哈希表，map使用有技巧！_哔哩哔哩_bilibili"></a><a href="https://www.bilibili.com/video/BV1aT41177mK/?spm_id_from=333.1387.collection.video_card.click&amp;vd_source=db8b493990184e57185c5ce1734577f2">梦开始的地方，Leetcode：1.两数之和，学透哈希表，map使用有技巧！_哔哩哔哩_bilibili</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="type">int</span> s = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(s);</span><br><span class="line">            <span class="keyword">if</span> (it!=map.<span class="built_in">end</span>()){</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            }</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）"><a href="#3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）" class="headerlink" title="3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）"></a>3、你知道的，代码和你有一个能跑就行。只不过这次是代码能跑（leetcode借鉴版）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> val = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">find</span>(val) == map.<span class="built_in">end</span>()) {</span><br><span class="line">                map[nums[i]] = i;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> {map[val], i};</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/ULTRAmanTAROACE/article/details/137115610">C++之STL整理（3）之map 用法（创建、赋值、方法）整理_c++ map初始化-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_48508278/article/details/118531197">C++中 Map的了解与基本用法（代码演示+自我总结+map中一对多的用法）_c++map函数的用法-CSDN博客</a></p>
<h1 id="leetcode-454-四数相加-II-1-22"><a href="#leetcode-454-四数相加-II-1-22" class="headerlink" title="leetcode 454. 四数相加 II 1.22"></a>leetcode <a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a> 1.22</h1><h2 id="题面-属于第一眼看会懵逼系列"><a href="#题面-属于第一眼看会懵逼系列" class="headerlink" title="题面 属于第一眼看会懵逼系列"></a>题面 属于第一眼看会懵逼系列</h2><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p> <strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length</code></li>
<li><code>n == nums2.length</code></li>
<li><code>n == nums3.length</code></li>
<li><code>n == nums4.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li>
</ul>
<h2 id="题解：思路类似于242题，把前两个当作是一个整体，把a-b的出现的次数放进一个map中，然后遍历c和d，计算-c-d-，查找这个值是否在map中出现过"><a href="#题解：思路类似于242题，把前两个当作是一个整体，把a-b的出现的次数放进一个map中，然后遍历c和d，计算-c-d-，查找这个值是否在map中出现过" class="headerlink" title="题解：思路类似于242题，把前两个当作是一个整体，把a+b的出现的次数放进一个map中，然后遍历c和d，计算-(c+d)，查找这个值是否在map中出现过"></a>题解：思路类似于242题，把前两个当作是一个整体，把a+b的出现的次数放进一个map中，然后遍历c和d，计算-(c+d)，查找这个值是否在map中出现过</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;nums1.size() ;i++){</span></span><br><span class="line">        <span class="comment">//     for (int j=0;j&lt;nums2.size();j++){</span></span><br><span class="line">        <span class="comment">//         map[nums1[i]+nums2[j]]++;//在map中存放前两个数组的a+b以及出现的次数，用于后续计数</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a:nums1){<span class="comment">//遍历vector可以这么干</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b: nums2){</span><br><span class="line">                map[a+b]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;nums3.size();i++){</span></span><br><span class="line">        <span class="comment">//     for (int j=0;j&lt;nums4.size();j++){</span></span><br><span class="line">        <span class="comment">//         int t = -(nums3[i]+nums4[j]);</span></span><br><span class="line">        <span class="comment">//         if (map.find(t)!=map.end()){</span></span><br><span class="line">        <span class="comment">//             count+=map[t];</span></span><br><span class="line">        <span class="comment">//         }</span></span><br><span class="line">        <span class="comment">//     }</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c:nums3){</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d:nums4){</span><br><span class="line">                <span class="type">int</span> t = -(c+d);</span><br><span class="line">                <span class="keyword">if</span> (map.<span class="built_in">find</span>(t)!=map.<span class="built_in">end</span>()){</span><br><span class="line">                    count+=map[t];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-15-三数之和-1-25"><a href="#leetcode-15-三数之和-1-25" class="headerlink" title="leetcode 15. 三数之和 1.25"></a>leetcode <a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a> 1.25</h1><h2 id="该不会还是不会（即使看了三遍的Carl……"><a href="#该不会还是不会（即使看了三遍的Carl……" class="headerlink" title="该不会还是不会（即使看了三遍的Carl……)"></a>该不会还是不会（即使看了三遍的Carl……)</h2><h2 id="果然是梦破碎的地方-第一次看了三遍视频还没看明白的题目"><a href="#果然是梦破碎的地方-第一次看了三遍视频还没看明白的题目" class="headerlink" title="果然是梦破碎的地方 第一次看了三遍视频还没看明白的题目"></a>果然是梦破碎的地方 第一次看了三遍视频还没看明白的题目</h2><h2 id="题面-13"><a href="#题面-13" class="headerlink" title="题面"></a>题面</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="题解：双指针-乱七八糟的去重"><a href="#题解：双指针-乱七八糟的去重" class="headerlink" title="题解：双指针+乱七八糟的去重"></a>题解：双指针+乱七八糟的去重</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="comment">//a b c 三个数，i就是a，left是b，right是c</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每一次遍历，会把包含a的所有集合都扫描一遍了</span></span><br><span class="line">            <span class="comment">//换句话说，nums[i]是这个组合中最小的数，如果这个最小的数大于0了，三数相加就根本不可能是0了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对a去重,这里判断的是跟前一个元素，而不是后一个。</span></span><br><span class="line">            <span class="comment">//因为如果跟后一个进行判断的话，left在a的后一个，如果刚好一样的话，等于是说元组之间不能重复，不符合题意</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i<span class="number">+1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//因为已经排好序了，left比i大一点，right是最大的</span></span><br><span class="line">            <span class="keyword">while</span> (right&gt;left){</span><br><span class="line">                <span class="keyword">if</span> (nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[i],nums[left],nums[right]});</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">//b,c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[left]==nums[left<span class="number">+1</span>]) left++;</span><br><span class="line">					</span><br><span class="line">                    <span class="comment">//这里是得到一个组合之后再进行两个指针的收缩，开始的时候搞成了每一次循环都做一次操作</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_43547900/article/details/121972917">c++:vector sort()排序-CSDN博客</a></p>
<p><a href="https://www.programmercarl.com/0015.三数之和.html#思路">代码随想录</a></p>
<h1 id="leetcode18-四数之和-1-26"><a href="#leetcode18-四数之和-1-26" class="headerlink" title="leetcode18. 四数之和 1.26"></a>leetcode<a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a> 1.26</h1><h2 id="这题逆天完了"><a href="#这题逆天完了" class="headerlink" title="这题逆天完了"></a>这题逆天完了</h2><h2 id="题面-14"><a href="#题面-14" class="headerlink" title="题面"></a>题面</h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<h2 id="题解：最快的一版答案，重点在剪枝去重-我XXX-，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了"><a href="#题解：最快的一版答案，重点在剪枝去重-我XXX-，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了" class="headerlink" title="题解：最快的一版答案，重点在剪枝去重(我XXX)，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了"></a>题解：最快的一版答案，重点在剪枝去重(我XXX)，竟然还卡我数组长度和long靠。第一个剪枝用return，但是第二个只能是break，直接return的话就结束了，后续的i还没有遍历呢，其他注意点都在注释里了</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) {</span><br><span class="line">        <span class="comment">//思路类似于三数之和,在外面再套一个for循环代表第四个数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();<span class="comment">//不用这一步也行，一样的</span></span><br><span class="line">        <span class="keyword">if</span> (len&lt;<span class="number">4</span>) <span class="keyword">return</span> res;<span class="comment">//这个一定要，被一个[0]干傻了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-3</span>;i++){</span><br><span class="line">            <span class="comment">//可以理解为这是第一个指针</span></span><br><span class="line">            <span class="comment">//先做一步剪枝,这里要注意，nums[i]和target都要是正数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里的两个剪枝的话，效果一般，可加可不加</span></span><br><span class="line">            <span class="comment">//if(nums[i]&gt;target&amp;&amp;nums[i]&gt;0&amp;&amp;target&gt;=0) return res;</span></span><br><span class="line">            <span class="comment">//if (nums[i]&gt;target/4) return res;</span></span><br><span class="line">             <span class="comment">//对i去重</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来开始快乐的三数之和的部分咯</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;len<span class="number">-2</span>;j++){</span><br><span class="line">                <span class="comment">//j是三数之和中的i，也就是第二个数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//剪枝，这个Carl的二级剪枝没啥效果</span></span><br><span class="line">                <span class="comment">//if (nums[j]+nums[i]&gt;target&amp;&amp;target&gt;=0&amp;&amp;nums[i]+nums[j]&gt;0) break;</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//这个剪枝是看leetcode里面题解看到的，感觉很合理，而且确实剪枝了一部分</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j]+nums[i]&gt;target/<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">if</span> (j&gt;i<span class="number">+1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> left = j<span class="number">+1</span>;</span><br><span class="line">                <span class="type">int</span> right = len<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (left&lt;right){</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right]&gt;target) right--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right]&lt;target) left++;</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">//放入结果</span></span><br><span class="line">                        res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[i],nums[j],nums[left],nums[right]});</span><br><span class="line">                        <span class="comment">//对left和right去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[left]==nums[left<span class="number">+1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//移动left和right</span></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/CFY1226/article/details/131386022">Char 34: runtime error: addition of unsigned offset to 0x603000000070 overflowed to 0x60300000006c-CSDN博客</a></p>
<h1 id="leetcode-344-反转字符串-1-27"><a href="#leetcode-344-反转字符串-1-27" class="headerlink" title="leetcode 344. 反转字符串 1.27"></a>leetcode <a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a> 1.27</h1><h2 id="似乎是最简单的一集"><a href="#似乎是最简单的一集" class="headerlink" title="似乎是最简单的一集"></a>似乎是最简单的一集</h2><h2 id="题面-15"><a href="#题面-15" class="headerlink" title="题面"></a>题面</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = ["h","e","l","l","o"]</span><br><span class="line">输出：["o","l","l","e","h"]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = ["H","a","n","n","a","h"]</span><br><span class="line">输出：["h","a","n","n","a","H"]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符\</li>
</ul>
<h2 id="题解：来，四种"><a href="#题解：来，四种" class="headerlink" title="题解：来，四种"></a>题解：来，四种</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一：没想到swap</span></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;s.size()/2;i++){</span></span><br><span class="line">        <span class="comment">//     // char t = s[i];</span></span><br><span class="line">        <span class="comment">//     // s[i] = s[s.size()-i-1];</span></span><br><span class="line">        <span class="comment">//     // s[s.size()-i-1] = t;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二：题解是个好东西，swap：你好</span></span><br><span class="line">        <span class="comment">//     swap(s[i],s[s.size()-i-1]);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三：评论区是个好东西,reverse：你好</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四：看了Carl的视频之后，感觉双指针更清晰一点（虽然原理上差不多）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;i++,j--){</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-541-反转字符串-II-1-27"><a href="#leetcode-541-反转字符串-II-1-27" class="headerlink" title="leetcode 541. 反转字符串 II 1.27"></a>leetcode <a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a> 1.27</h1><h2 id="问就是不会……"><a href="#问就是不会……" class="headerlink" title="问就是不会……"></a>问就是不会……</h2><h2 id="题面-16"><a href="#题面-16" class="headerlink" title="题面"></a>题面</h2><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = "abcdefg", k = 2</span><br><span class="line">输出："bacdfeg"</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = "abcd", k = 2</span><br><span class="line">输出："bacd"</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由小写英文组成</li>
<li><code>1 &lt;= k &lt;= 104</code></li>
</ul>
<h2 id="题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数"><a href="#题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数" class="headerlink" title="题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数"></a>题解：两种方法，第一种直接用reverse函数，第二种，自己实现reverse函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="comment">//i+=2k是直接跳到2K处，可以减少运算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i+=<span class="number">2</span>*k){</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这个是为了反转前k个字符的判断条件，针对每一个i，不论是否满足2k，只要满足有k个就反转。</span></span><br><span class="line">            <span class="comment">//小于等于s.size()是针对于最后一部分的判断。注意这里有等号</span></span><br><span class="line">            <span class="keyword">if</span> (i+k&lt;=s.<span class="built_in">size</span>()){</span><br><span class="line">                <span class="comment">//reverse函数可以这样用，从第i位开始s.begin()+i。</span></span><br><span class="line">                <span class="comment">//而且reverse函数实现的时候是左闭右开的，第二个参数直接加上就行了</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">begin</span>()+i+k);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">end</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">};</span><br><span class="line"><span class="comment">//方法二，手写reverse函数，注意这里要用&amp;引用，这样才能保证操作的是同一个string。亲测，没加上没用。并且使用双指针，比只有一个变量方便多了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=start,j=end;i&lt;j;i++,j--){</span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i+=<span class="number">2</span>*k){</span><br><span class="line">            <span class="keyword">if</span> (i+k&lt;=s.<span class="built_in">size</span>()){</span><br><span class="line">                <span class="comment">//由于是自己定义的，这里的end就需要-1.</span></span><br><span class="line">                <span class="built_in">reverse</span>(s,i,i+k<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">reverse</span>(s,i,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.programmercarl.com/0541.反转字符串II.html#思路">代码随想录</a></p>
<h1 id="leetcode151-151-反转字符串中的单词-25-3-7"><a href="#leetcode151-151-反转字符串中的单词-25-3-7" class="headerlink" title="leetcode151 151. 反转字符串中的单词 25.3.7"></a>leetcode151 <a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a> 25.3.7</h1><h2 id="孩子我回来啦-一整个2月份在焦虑和自我内耗中度过……"><a href="#孩子我回来啦-一整个2月份在焦虑和自我内耗中度过……" class="headerlink" title="孩子我回来啦 一整个2月份在焦虑和自我内耗中度过……"></a>孩子我回来啦 一整个2月份在焦虑和自我内耗中度过……</h2><h2 id="题面-17"><a href="#题面-17" class="headerlink" title="题面"></a>题面</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = "the sky is blue"</span><br><span class="line">输出："blue is sky the"</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = "  hello world  "</span><br><span class="line">输出："world hello"</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = "a good   example"</span><br><span class="line">输出："example good a"</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li>
<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>
</ul>
<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>
<h2 id="题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了"><a href="#题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了" class="headerlink" title="题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了"></a>题解：问就是看Carl的书，现在觉得书比视频来的舒服。用双指针删除多余空格，注意点都在注释里了</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//反转单个单词</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string &amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start,j=end;i&lt;j;i++,j--){</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除多余空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removespace</span><span class="params">(string &amp;s)</span></span>{</span><br><span class="line">        <span class="type">int</span> fastindex=<span class="number">0</span>,slowindex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//去除开头的空格</span></span><br><span class="line">        <span class="keyword">while</span> (s[fastindex]==<span class="string">' '</span>&amp;&amp;fastindex&lt;s.<span class="built_in">size</span>()) fastindex++;</span><br><span class="line">        <span class="comment">//去除中间的空格，但是保证单词中间还有一个空格</span></span><br><span class="line">        <span class="keyword">for</span> (;fastindex&lt;s.<span class="built_in">size</span>();fastindex++){</span><br><span class="line">            <span class="keyword">if</span> (fastindex<span class="number">-1</span>&gt;<span class="number">0</span> <span class="comment">//这个是保证下面两个条件的一个前提</span></span><br><span class="line">            &amp;&amp;s[fastindex] == s[fastindex<span class="number">-1</span>] </span><br><span class="line">            &amp;&amp;s[fastindex]==<span class="string">' '</span> </span><br><span class="line">            <span class="comment">//需要我忽略的是中间有两个空格的时候。换句话说就是当遇到中间有两个空格的时候</span></span><br><span class="line">            <span class="comment">//不移动slowindex指针，让后面的字符来覆盖前面的空格</span></span><br><span class="line">            ) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> s[slowindex++] = s[fastindex];</span><br><span class="line">            <span class="comment">//这个操作会把最后末尾的空格也加进来,如果末尾还有空格的话</span></span><br><span class="line">            <span class="comment">//会刚好再多读入一个空格，如果没有的话就不会</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//去除末尾空格,如果有空格的话，</span></span><br><span class="line">        <span class="comment">// while (s[slowindex]==' ' &amp;&amp;slowindex&gt;0) slowindex--;</span></span><br><span class="line">        <span class="comment">// s.resize(slowindex);</span></span><br><span class="line">        <span class="keyword">if</span> (s[slowindex<span class="number">-1</span>]==<span class="string">' '</span>) <span class="comment">//这里是判断字符串的最后一位是不是空格</span></span><br><span class="line">            s.<span class="built_in">resize</span>(slowindex<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">resize</span>(slowindex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="built_in">removespace</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> entry = <span class="literal">false</span>; <span class="comment">//这个是判断是否进入字符串，反转每个单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">if</span> ((!entry)||(s[i<span class="number">-1</span>]==<span class="string">' '</span>&amp;&amp;s[i]!=<span class="string">' '</span>)){</span><br><span class="line">                begin = i;</span><br><span class="line">                entry = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (entry &amp;&amp; s[i]==<span class="string">' '</span>&amp;&amp; s[i<span class="number">-1</span>]!=<span class="string">' '</span>){ <span class="comment">//这里如果用i+1来判断的话有可能溢出</span></span><br><span class="line">                end = i<span class="number">-1</span>;</span><br><span class="line">                entry = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">reverse</span>(s,begin,end);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (entry &amp;&amp; (i==s.<span class="built_in">size</span>()<span class="number">-1</span>) &amp;&amp; s[i]!=<span class="string">' '</span>){ <span class="comment">//这是判断最后一个单词，后面没有空格了</span></span><br><span class="line">                end = i;</span><br><span class="line">                entry = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">reverse</span>(s,begin,end);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-455-455-分发饼干-25-3-8"><a href="#leetcode-455-455-分发饼干-25-3-8" class="headerlink" title="leetcode 455 455. 分发饼干 25.3.8"></a>leetcode 455 <a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a> 25.3.8</h1><p>想学贪心和dp了</p>
<h2 id="题面-18"><a href="#题面-18" class="headerlink" title="题面"></a>题面</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。</span><br><span class="line">所以你应该输出 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出 2。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= g.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li>
</ul>
<h2 id="题解：先排个序，从小到大看饼干能满足哪些小孩"><a href="#题解：先排个序，从小到大看饼干能满足哪些小孩" class="headerlink" title="题解：先排个序，从小到大看饼干能满足哪些小孩"></a>题解：先排个序，从小到大看饼干能满足哪些小孩</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">if</span> (index&lt;g.<span class="built_in">size</span>() &amp;&amp; g[index]&lt;=s[i]){</span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-376-376-摆动序列-25-3-10"><a href="#leetcode-376-376-摆动序列-25-3-10" class="headerlink" title="leetcode 376 376. 摆动序列 25.3.10"></a>leetcode 376 <a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a> 25.3.10</h1><p>昨天有点摆了</p>
<h2 id="题面-19"><a href="#题面-19" class="headerlink" title="题面"></a>题面</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>
<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这个序列包含几个长度为 7 摆动序列。</span><br><span class="line">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p>
<h2 id="题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。"><a href="#题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。" class="headerlink" title="题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。"></a>题解：贪心，（但是我没感觉出来）要特别注意不单调但有平坡和单调有平坡两种情况。就当作是路上的积累吧，背下来就好了。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">//当前的差值</span></span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>; <span class="comment">//之前的插值</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>; <span class="comment">//假设最后有一个峰值，默认为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++){</span><br><span class="line">            cur = nums[i<span class="number">+1</span>] - nums[i];</span><br><span class="line">            <span class="comment">//这里的判断条件，pre可以等于0是为了满足有不单调但中间有平坡的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((cur&gt;<span class="number">0</span>&amp;&amp;pre&lt;=<span class="number">0</span>)||(pre&gt;=<span class="number">0</span>&amp;&amp;cur&lt;<span class="number">0</span>)){</span><br><span class="line">                res++;</span><br><span class="line">                pre = cur;</span><br><span class="line">                <span class="comment">//pre放在这里赋值时为了解决单调有平坡的情况，pre不需要每次都跟着cur改变，只需要记录有变化的时候</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-53-53-最大子数组和-25-3-14"><a href="#leetcode-53-53-最大子数组和-25-3-14" class="headerlink" title="leetcode 53 53. 最大子数组和 25.3.14"></a>leetcode 53 <a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a> 25.3.14</h1><p>emmm刚搞完一个分享会，ppt做的好累</p>
<h2 id="题面-20"><a href="#题面-20" class="headerlink" title="题面"></a>题面</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h2 id="题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums-i-1-。不是在遇到负数就下一个。只要count还是-gt-0就还对下一个数有增大作用。是在count-lt-0才要跳过。"><a href="#题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums-i-1-。不是在遇到负数就下一个。只要count还是-gt-0就还对下一个数有增大作用。是在count-lt-0才要跳过。" class="headerlink" title="题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums[i+1]。不是在遇到负数就下一个。只要count还是>0就还对下一个数有增大作用。是在count<0才要跳过。"></a>题解：需要关注的是，贪心贪在哪里。它需要找的是局部最优解，通过局部最优找到全局最优。这题主要是关注的是nums[i+1]。不是在遇到负数就下一个。只要count还是&gt;0就还对下一个数有增大作用。是在count&lt;0才要跳过。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-99999</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//记录每个区间的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (count&gt;res) res = count;</span><br><span class="line">            <span class="keyword">if</span> (count&lt;<span class="number">0</span>) count=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//不是遇到负数就直接跳过，而是整体为负数才跳过。</span></span><br><span class="line">            <span class="comment">//只要我这一部分的和还是正数，对于后面的数就是一个增大的作用，关心的主体是nums[i+1]</span></span><br><span class="line">            <span class="comment">//整体为负数会拖累后面累加的数，不会让总体的和更大，不如重新开始</span></span><br><span class="line">            <span class="comment">//而且每次都及时更新到res里面了，不用担心会丢下最大值</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-122-122-买卖股票的最佳时机-II-25-3-15"><a href="#leetcode-122-122-买卖股票的最佳时机-II-25-3-15" class="headerlink" title="leetcode 122 122. 买卖股票的最佳时机 II 25.3.15"></a>leetcode 122 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a> 25.3.15</h1><p>昨晚太晚睡了，今天一整天都没精神</p>
<h2 id="题面-21"><a href="#题面-21" class="headerlink" title="题面"></a>题面</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。</span><br><span class="line">最大总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">最大总利润为 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<h2 id="题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值"><a href="#题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值" class="headerlink" title="题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值"></a>题解：贪心。每次都关注局部最大值，然后最后合在一起得到全局最大值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里实际构建了一个新的数组，就是每天的利润</span></span><br><span class="line">        <span class="comment">// 我需要找到的是每天的利润都为正数的天数全加起来就可以了</span></span><br><span class="line">        <span class="comment">// 因为比如第一天买入，第三天卖出</span></span><br><span class="line">        <span class="comment">// prices[3]-prices[0] = prices[3]-prices[2]+prices[2]-prices[1]+prices[1]-prices[0]</span></span><br><span class="line">        <span class="comment">// 要保证利润最大，就是只需要每两个之间的差值为正数就是赚</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++){</span><br><span class="line">            res += <span class="built_in">max</span>((prices[i]-prices[i<span class="number">-1</span>]),<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-55-55-跳跃游戏-25-3-17"><a href="#leetcode-55-55-跳跃游戏-25-3-17" class="headerlink" title="leetcode 55 55. 跳跃游戏 25.3.17"></a>leetcode 55 <a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a> 25.3.17</h1><p>昨天周日，六刷thu</p>
<h2 id="题面-22"><a href="#题面-22" class="headerlink" title="题面"></a>题面</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）"><a href="#我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）" class="headerlink" title="我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）"></a>我自己的版本。看到题面就觉得只要能到达最远的地方就行，取max最重要。结果一交发现了一堆问题，那三个if是对着错误样例改出来的（捂脸）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res,nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==<span class="number">0</span> &amp;&amp; res == i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="代码随想录版本，更加简洁，直接用了cover，然后还直接让i-lt-cover，直接就卡死了它的范围，就不会出现我自己写的那些问题"><a href="#代码随想录版本，更加简洁，直接用了cover，然后还直接让i-lt-cover，直接就卡死了它的范围，就不会出现我自己写的那些问题" class="headerlink" title="代码随想录版本，更加简洁，直接用了cover，然后还直接让i<=cover，直接就卡死了它的范围，就不会出现我自己写的那些问题"></a>代码随想录版本，更加简洁，直接用了cover，然后还直接让i&lt;=cover，直接就卡死了它的范围，就不会出现我自己写的那些问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> cover = nums[<span class="number">0</span>]; <span class="comment">//int cover = 0;等于0，等于nums[0]都可以</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=cover;i++){</span><br><span class="line">            cover = <span class="built_in">max</span>(cover,nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span> (cover&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-45-45-跳跃游戏-II-25-3-23"><a href="#leetcode-45-45-跳跃游戏-II-25-3-23" class="headerlink" title="leetcode 45 45. 跳跃游戏 II 25.3.23"></a>leetcode 45 <a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a> 25.3.23</h1><p>精彩的一周，没想到这周能发生让我如此印象深刻的一件事</p>
<h2 id="题面-23"><a href="#题面-23" class="headerlink" title="题面"></a>题面</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>题目保证可以到达 <code>nums[n-1]</code></li>
</ul>
<h2 id="题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums-size-1的话，就需要将ans-。"><a href="#题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums-size-1的话，就需要将ans-。" class="headerlink" title="题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums.size()-1的话，就需要将ans++。"></a>题解：要找最少步数，就是看当每一次的cover能到达的最远的地方。如果能到最远的地方但是还到不了nums.size()-1的话，就需要将ans++。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cover=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre_cover = <span class="number">0</span>; <span class="comment">//用来标记在第一次能到达的最远距离，然后再依据这个更新。这一部分是跳一次之内都能达到的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            cover = <span class="built_in">max</span>(i+nums[i],cover);</span><br><span class="line">            <span class="comment">//计算在这个能达到的最远区间中延伸出去所能达到的最远，最远的那里只需要跳一次就能到</span></span><br><span class="line">            <span class="keyword">if</span> (i==pre_cover){ </span><br><span class="line">            <span class="comment">//看第一次最远能到哪里，当已经遇到最远的地方的时候，它延伸出来的cover能有多少，之后再继续更新</span></span><br><span class="line">                <span class="keyword">if</span> (pre_cover&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>) {</span><br><span class="line">                    ans++;</span><br><span class="line">                    pre_cover=cover;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-274-274-H-指数-25-3-23"><a href="#leetcode-274-274-H-指数-25-3-23" class="headerlink" title="leetcode 274 274. H 指数 25.3.23"></a>leetcode 274 <a href="https://leetcode.cn/problems/h-index/">274. H 指数</a> 25.3.23</h1><p>先看到的这题，然后才拿出的代码随想录</p>
<h2 id="题面-24"><a href="#题面-24" class="headerlink" title="题面"></a>题面</h2><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code> 指数</strong>。</p>
<p>根据维基百科上 <a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code> <strong>指数</strong> 是指他（她）至少发表了 <code>h</code> 篇论文，并且 <strong>至少</strong> 有 <code>h</code> 篇论文被引用次数大于等于 <code>h</code> 。如果 <code>h</code> 有多种可能的值，<strong><code>h</code> 指数</strong> 是其中最大的那个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：citations = [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：citations = [1,3,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == citations.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>
</ul>
<h2 id="题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i-1小了就是答案"><a href="#题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i-1小了就是答案" class="headerlink" title="题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i+1小了就是答案"></a>题解：怪我太菜了，这还是看了题解才会的，原来我没想到。直接倒叙排序一下就好了，再看一下到哪里它的下标跟i+1小了就是答案</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(citations.<span class="built_in">begin</span>(),citations.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//直接倒叙排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;citations.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">if</span> (citations[i]&lt;i<span class="number">+1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> citations.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-LCR-134-Pow-x-n-25-3-28"><a href="#leetcode-LCR-134-Pow-x-n-25-3-28" class="headerlink" title="leetcode LCR 134. Pow(x, n) 25.3.28"></a>leetcode <a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">LCR 134. Pow(x, n)</a> 25.3.28</h1><p>一开始直接 <script type="math/tex">pow(x,n)</script> 过了，结果一看要用快速幂，赶紧补了一下</p>
<h2 id="题面-25"><a href="#题面-25" class="headerlink" title="题面"></a>题面</h2><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>-100.0 &lt; x &lt; 100.0</code></li>
<li><code>-231 &lt;= n &lt;= 231-1</code></li>
<li><code>-104 &lt;= xn &lt;= 104</code></li>
</ul>
<h2 id="题解：直接放快速幂的吧"><a href="#题解：直接放快速幂的吧" class="headerlink" title="题解：直接放快速幂的吧"></a>题解：直接放快速幂的吧</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">1</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> num = n;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">0</span>){</span><br><span class="line">            num = - num;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (num){ <span class="comment">//重点是这几行</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp; <span class="number">1</span>) ans *=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="GPT老师对于代码的解析："><a href="#GPT老师对于代码的解析：" class="headerlink" title="GPT老师对于代码的解析："></a>GPT老师对于代码的解析：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(num){</span><br><span class="line">    <span class="keyword">if</span>(num &amp; <span class="number">1</span>) ans *= x;  <span class="comment">// 如果 num 的最低位是 1，则累乘 x</span></span><br><span class="line">    x *= x;                <span class="comment">// x 自乘，相当于 x^(2^i)</span></span><br><span class="line">    num &gt;&gt;= <span class="number">1</span>;             <span class="comment">// 右移 num，相当于 num //= 2</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="逐行分析："><a href="#逐行分析：" class="headerlink" title="逐行分析："></a>逐行分析：</h4><ol>
<li><strong><code>while(num)</code></strong><ul>
<li>只要 <code>num</code> 不为 <code>0</code>，就继续循环，即处理 <code>num</code> 的二进制表示的每一位。</li>
</ul>
</li>
<li><strong><code>if(num &amp; 1) ans \*= x;</code></strong><ul>
<li><code>num &amp; 1</code> 用于检查 <code>num</code> 的最低位是否为 <code>1</code>：<ul>
<li>如果 <code>num</code> 的最低位是 <code>1</code>，说明当前的 <code>x</code> 需要计入结果，因此将 <code>x</code> 乘入 <code>ans</code>。</li>
<li>例如：<code>3</code> 的二进制是 <code>11</code>，最低位 <code>1</code> 说明当前的 <code>x</code> 需要乘入 <code>ans</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>x *= x;</code></strong><ul>
<li><code>x</code> 进行平方，<code>x</code> 变成 <code>x^2</code>，然后 <code>x^4</code>，<code>x^8</code>，依次递增。</li>
<li>这样通过二进制的方式，可以用少量的乘法完成指数计算。</li>
</ul>
</li>
<li><strong><code>num &gt;&gt;= 1;</code></strong><ul>
<li><code>num</code> 右移一位，相当于 <code>num //= 2</code>，去掉最低位，继续处理下一位。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="例子分析："><a href="#例子分析：" class="headerlink" title="例子分析："></a>例子分析：</h3><p>计算 <script type="math/tex">3^{13}</script></p>
<h4 id="计算步骤："><a href="#计算步骤：" class="headerlink" title="计算步骤："></a>计算步骤：</h4><p><code>13</code> 的二进制是 <strong><code>1101</code></strong><br> 从右到左遍历，每一位表示是否需要乘入当前的 <code>x</code>（即 <code>3^(2^i)</code>）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>num (二进制)</th>
<th>x (当前幂)</th>
<th>ans（累乘结果）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1101 (13)</strong></td>
<td>3</td>
<td>3</td>
<td>最低位是 1，乘入 ans</td>
</tr>
<tr>
<td><strong>110 (6)</strong></td>
<td>9</td>
<td>3</td>
<td>最低位是 0，跳过</td>
</tr>
<tr>
<td><strong>11 (3)</strong></td>
<td>81</td>
<td>3 × 81 = 243</td>
<td>最低位是 1，乘入 ans</td>
</tr>
<tr>
<td><strong>1 (1)</strong></td>
<td>6561</td>
<td>243 × 6561 = 1594323</td>
<td>最低位是 1，乘入 ans</td>
</tr>
</tbody>
</table>
</div>
<p>最终 <code>ans = 1594323</code>，即 <script type="math/tex">3^{13}=15943233</script>.</p>
<h1 id="leetcode-134-加油站-25-3-28"><a href="#leetcode-134-加油站-25-3-28" class="headerlink" title="leetcode 134. 加油站 25.3.28"></a>leetcode <a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a> 25.3.28</h1><p>贪心ing</p>
<h2 id="题面-26"><a href="#题面-26" class="headerlink" title="题面"></a>题面</h2><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>gas.length == n</code></li>
<li><code>cost.length == n</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li>
</ul>
<h2 id="题解：在每次遇到cursum-lt-0的时候，就证明说起点要从下一个开始"><a href="#题解：在每次遇到cursum-lt-0的时候，就证明说起点要从下一个开始" class="headerlink" title="题解：在每次遇到cursum<0的时候，就证明说起点要从下一个开始"></a>题解：在每次遇到cursum&lt;0的时候，就证明说起点要从下一个开始</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="type">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.<span class="built_in">size</span>();i++){</span><br><span class="line">            cursum += gas[i] - cost[i];</span><br><span class="line">            totalsum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (cursum&lt;<span class="number">0</span>){</span><br><span class="line">                start = i<span class="number">+1</span>;</span><br><span class="line">                cursum = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (totalsum&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数媒注意点</title>
    <url>/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/</url>
    <content><![CDATA[<p>又是基本没用上系列<br><span id="more"></span></p>
<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/1.png" class="" title="img">
<p>要计算一张100x100的彩色图像（假设是24位彩色，即每个像素用3个字节表示）的文件大小，可以按照以下步骤进行：</p>
<ol>
<li>计算像素总数：100像素 × 100像素 = 10,000像素。</li>
<li>计算每个像素的字节数：24位彩色图像，每个像素用3个字节表示。</li>
<li>计算总字节数：10,000像素 × 3字节/像素 = 30,000字节。</li>
<li>将字节转换为KB：30,000字节 ÷ 1,024字节/KB ≈ 29.29KB。</li>
</ol>
<p>因此，一张100x100的24位彩色图像，不经过压缩，文件大小大约是30KB。</p>
<p>选项B（30KB）是正确的。</p>
<h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、<img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/2.png" class="" title="img"></h4><h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、<img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/3.png" class="" title="img"></h4><h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、<img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/4.png" class="" title="img"></h4><p>长6个cell高4个cell，bin=5，一个cell出5个数，一个block出4 × 5=20个数，一共有（6-1） × （4-1）=5 × 3=15个block，所以一共15 × 20=300</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><h4 id="1、饱和度对比度亮度，重点是对比度"><a href="#1、饱和度对比度亮度，重点是对比度" class="headerlink" title="1、饱和度对比度亮度，重点是对比度"></a>1、饱和度对比度亮度，重点是对比度</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对比度调整 先算出图片均值，计算每个像素喝均值的差，乘以对比度因子，再加上均值和亮度值</span></span><br><span class="line">mean = np.mean(saturation_img)</span><br><span class="line">alpha = <span class="variable language_">self</span>.contrast_slider.value() / <span class="number">100.0</span></span><br><span class="line">beta = <span class="variable language_">self</span>.brightness_slider.value()</span><br><span class="line">contrast_img = (saturation_img - mean) * alpha + mean + beta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保像素值在 [0, 255] 范围内</span></span><br><span class="line">contrast_img = np.clip(contrast_img, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">brightness_img = cv2.convertScaleAbs(contrast_img, alpha=<span class="number">1</span>, beta=<span class="variable language_">self</span>.brightness_slider.value())</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QPushButton, QVBoxLayout, QHBoxLayout, QLabel, QFileDialog, QSlider, QWidget,QMessageBox</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QImage, QPixmap</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>(<span class="title class_ inherited__">QMainWindow</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.setWindowTitle(<span class="string">"Saturation and Contrast Adjustment"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取屏幕尺寸</span></span><br><span class="line">        screen = QApplication.primaryScreen()</span><br><span class="line">        screen_geometry = screen.geometry()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取窗口尺寸</span></span><br><span class="line">        window_width, window_height = <span class="number">800</span>, <span class="number">600</span></span><br><span class="line">        window_geometry = <span class="variable language_">self</span>.frameGeometry()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算窗口在屏幕中的中心位置</span></span><br><span class="line">        center_point = screen_geometry.center()</span><br><span class="line">        window_geometry.moveCenter(center_point)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置窗口的位置</span></span><br><span class="line">        <span class="variable language_">self</span>.setGeometry(window_geometry.x(), window_geometry.y(), window_width, window_height)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.init_ui()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_ui</span>(<span class="params">self</span>):</span><br><span class="line">        central_widget = QWidget(<span class="variable language_">self</span>)</span><br><span class="line">        layout = QVBoxLayout(central_widget)    </span><br><span class="line">        <span class="comment"># central Widget 里面的主layout</span></span><br><span class="line">        <span class="comment">#mainLayout = QtWidgets.QVBoxLayout(central_widget)</span></span><br><span class="line">        <span class="comment">#界面的上半部分 : 滑动条展示部分</span></span><br><span class="line">        topLayout = QtWidgets.QVBoxLayout()      </span><br><span class="line">        <span class="comment"># 饱和度滑动条及其提示标签</span></span><br><span class="line">        saturation_layout = QVBoxLayout()</span><br><span class="line">        <span class="variable language_">self</span>.saturation_slider = QSlider(Qt.Horizontal, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.saturation_slider.setMinimum(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.saturation_slider.setMaximum(<span class="number">200</span>)</span><br><span class="line">        <span class="variable language_">self</span>.saturation_slider.setValue(<span class="number">100</span>)</span><br><span class="line">        <span class="variable language_">self</span>.saturation_slider.valueChanged[<span class="built_in">int</span>].connect(<span class="variable language_">self</span>.update_saturation)</span><br><span class="line">        <span class="variable language_">self</span>.saturation_label = QLabel(<span class="string">"Saturation: 100%"</span>, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.saturation_label.setAlignment(Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.saturation_slider.hide()</span><br><span class="line">        <span class="variable language_">self</span>.saturation_label.hide()</span><br><span class="line">        saturation_layout.addWidget(<span class="variable language_">self</span>.saturation_slider)</span><br><span class="line">        saturation_layout.addWidget(<span class="variable language_">self</span>.saturation_label)</span><br><span class="line">        topLayout.addLayout(saturation_layout)    </span><br><span class="line">        <span class="comment"># 对比度滑动条及其提示标签</span></span><br><span class="line">        contrast_layout = QVBoxLayout()</span><br><span class="line">        <span class="variable language_">self</span>.contrast_slider = QSlider(Qt.Horizontal, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.contrast_slider.setMinimum(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.contrast_slider.setMaximum(<span class="number">200</span>)</span><br><span class="line">        <span class="variable language_">self</span>.contrast_slider.setValue(<span class="number">100</span>)</span><br><span class="line">        <span class="variable language_">self</span>.contrast_slider.valueChanged[<span class="built_in">int</span>].connect(<span class="variable language_">self</span>.update_contrast)</span><br><span class="line">        <span class="variable language_">self</span>.contrast_label = QLabel(<span class="string">"Contrast: 100%"</span>, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.contrast_label.setAlignment(Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.contrast_slider.hide()</span><br><span class="line">        <span class="variable language_">self</span>.contrast_label.hide()</span><br><span class="line">        contrast_layout.addWidget(<span class="variable language_">self</span>.contrast_slider)</span><br><span class="line">        contrast_layout.addWidget(<span class="variable language_">self</span>.contrast_label)</span><br><span class="line">        topLayout.addLayout(contrast_layout)   </span><br><span class="line">        <span class="comment"># 亮度滑动条及其提示标签x</span></span><br><span class="line">        brightness_layout = QVBoxLayout()</span><br><span class="line">        <span class="variable language_">self</span>.brightness_slider = QSlider(Qt.Horizontal, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.brightness_slider.setMinimum(-<span class="number">100</span>)</span><br><span class="line">        <span class="variable language_">self</span>.brightness_slider.setMaximum(<span class="number">100</span>)</span><br><span class="line">        <span class="variable language_">self</span>.brightness_slider.setValue(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.brightness_slider.valueChanged[<span class="built_in">int</span>].connect(<span class="variable language_">self</span>.update_brightness)</span><br><span class="line">        <span class="variable language_">self</span>.brightness_label = QLabel(<span class="string">"Brightness: 0%"</span>, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.brightness_label.setAlignment(Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.brightness_slider.hide()</span><br><span class="line">        <span class="variable language_">self</span>.brightness_label.hide()</span><br><span class="line">        brightness_layout.addWidget(<span class="variable language_">self</span>.brightness_slider)</span><br><span class="line">        brightness_layout.addWidget(<span class="variable language_">self</span>.brightness_label)</span><br><span class="line">        topLayout.addLayout(brightness_layout)</span><br><span class="line">        layout.addLayout(topLayout)       </span><br><span class="line">        <span class="comment">#下半部分</span></span><br><span class="line">        lowLayout = QtWidgets.QHBoxLayout()</span><br><span class="line">        <span class="comment">#原图</span></span><br><span class="line">        original_layout = QVBoxLayout()</span><br><span class="line">        <span class="comment"># 文件选择按钮   </span></span><br><span class="line">        <span class="variable language_">self</span>.text = QLabel(<span class="string">"饱和度、对比度、亮度调整"</span>)</span><br><span class="line">        <span class="variable language_">self</span>.text.setAlignment(Qt.AlignCenter)</span><br><span class="line">        original_layout.addWidget(<span class="variable language_">self</span>.text)  </span><br><span class="line">        <span class="variable language_">self</span>.button = QPushButton(<span class="string">'请选择图片文件'</span>, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.button.setFixedSize(<span class="number">250</span>,<span class="number">30</span>)</span><br><span class="line">        <span class="variable language_">self</span>.button.clicked.connect(<span class="variable language_">self</span>.load_image)</span><br><span class="line">        original_layout.addWidget(<span class="variable language_">self</span>.button,alignment=Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.text_ori = QLabel(<span class="string">"原图"</span>,<span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.text_ori.setAlignment(Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.text_ori.hide()</span><br><span class="line">        original_layout.addWidget(<span class="variable language_">self</span>.text_ori)</span><br><span class="line">        <span class="comment">#图片在中间显示</span></span><br><span class="line">        <span class="variable language_">self</span>.ori_image_label = QLabel(<span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.ori_image_label.setAlignment(Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.ori_image_label.hide()</span><br><span class="line">        original_layout.addWidget(<span class="variable language_">self</span>.ori_image_label)        </span><br><span class="line">        lowLayout.addLayout(original_layout)</span><br><span class="line">        <span class="comment">#变换之后</span></span><br><span class="line">        changed_layout = QVBoxLayout()</span><br><span class="line">        <span class="comment">#图片下载按钮</span></span><br><span class="line">        <span class="variable language_">self</span>.button_download = QPushButton(<span class="string">'保存变换之后的图片'</span>, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.button_download.setFixedSize(<span class="number">250</span>,<span class="number">30</span>)</span><br><span class="line">        <span class="variable language_">self</span>.button_download.clicked.connect(<span class="variable language_">self</span>.download_image)</span><br><span class="line">        <span class="variable language_">self</span>.button_download.hide()</span><br><span class="line">        changed_layout.addWidget(<span class="variable language_">self</span>.button_download,alignment=Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.text_chan = QLabel(<span class="string">"变换图"</span>,<span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.text_chan.setAlignment(Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.text_chan.hide()</span><br><span class="line">        changed_layout.addWidget(<span class="variable language_">self</span>.text_chan)</span><br><span class="line">        <span class="comment"># 图像标签</span></span><br><span class="line">        <span class="variable language_">self</span>.changed_image_label = QLabel(<span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.changed_image_label.setAlignment(Qt.AlignCenter)</span><br><span class="line">        <span class="variable language_">self</span>.changed_image_label.hide()</span><br><span class="line">        changed_layout.addWidget(<span class="variable language_">self</span>.changed_image_label)</span><br><span class="line">        lowLayout.addLayout(changed_layout)</span><br><span class="line">        layout.addLayout(lowLayout)  </span><br><span class="line">        <span class="variable language_">self</span>.setCentralWidget(central_widget)</span><br><span class="line">        <span class="variable language_">self</span>.image = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.changed_image=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">self</span>):</span><br><span class="line">        options = QFileDialog.Options()</span><br><span class="line">        <span class="comment">#如果已经打开一张图片，想要打开第二张图片先将第一张图片清空</span></span><br><span class="line">        <span class="comment"># if self.image is not None:</span></span><br><span class="line">        <span class="comment">#     self.image = None</span></span><br><span class="line">        <span class="comment">#     self.update_image()</span></span><br><span class="line">        file_name, _ = QFileDialog.getOpenFileName(<span class="variable language_">self</span>, <span class="string">"Open Image"</span>, <span class="string">""</span>, <span class="string">"Image Files (*.png *.jpg *.bmp)"</span>, options=options)</span><br><span class="line">        <span class="keyword">if</span> file_name:            </span><br><span class="line">            <span class="variable language_">self</span>.image = cv2.imread(file_name)</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.image <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                QMessageBox.warning(<span class="variable language_">self</span>, <span class="string">"Warning"</span>, <span class="string">"图片打开失败，文件名或路径包含中文，不可识别，请将文件放置在英文路径下"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="variable language_">self</span>.image = cv2.resize(<span class="variable language_">self</span>.image, (<span class="number">400</span>,<span class="number">400</span>))</span><br><span class="line">            <span class="variable language_">self</span>.saturation_slider.setValue(<span class="number">100</span>)</span><br><span class="line">            <span class="variable language_">self</span>.contrast_slider.setValue(<span class="number">100</span>)</span><br><span class="line">            <span class="variable language_">self</span>.brightness_slider.setValue(<span class="number">0</span>)</span><br><span class="line">            <span class="variable language_">self</span>.update_image()</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">self</span>.text.hide()</span><br><span class="line">            <span class="variable language_">self</span>.saturation_label.show()</span><br><span class="line">            <span class="variable language_">self</span>.saturation_slider.show()</span><br><span class="line">            <span class="variable language_">self</span>.contrast_label.show()</span><br><span class="line">            <span class="variable language_">self</span>.contrast_slider.show()</span><br><span class="line">            <span class="variable language_">self</span>.brightness_label.show()</span><br><span class="line">            <span class="variable language_">self</span>.brightness_slider.show()</span><br><span class="line">            <span class="variable language_">self</span>.text_ori.show()</span><br><span class="line">            <span class="variable language_">self</span>.ori_image_label.show()</span><br><span class="line">            <span class="variable language_">self</span>.text_chan.show()</span><br><span class="line">            <span class="variable language_">self</span>.button_download.show()</span><br><span class="line">            <span class="variable language_">self</span>.changed_image_label.show()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#提示图片上传失败</span></span><br><span class="line">            QMessageBox.warning(<span class="variable language_">self</span>, <span class="string">"Warning"</span>, <span class="string">"图片上传失败"</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_image</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.image <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            hsv_img = cv2.cvtColor(<span class="variable language_">self</span>.image, cv2.COLOR_BGR2HSV)</span><br><span class="line">            hsv_img[..., <span class="number">1</span>] = hsv_img[..., <span class="number">1</span>] * (<span class="variable language_">self</span>.saturation_slider.value() / <span class="number">100.0</span>)</span><br><span class="line">            saturation_img = cv2.cvtColor(hsv_img, cv2.COLOR_HSV2BGR)</span><br><span class="line">            <span class="comment">#contrast_img = cv2.convertScaleAbs(saturation_img, alpha=self.contrast_slider.value() / 100.0, beta=0)</span></span><br><span class="line">            <span class="comment"># 对比度调整 先算出图片均值，计算每个像素喝均值的差，乘以对比度因子，再加上均值和亮度值</span></span><br><span class="line">            mean = np.mean(saturation_img)</span><br><span class="line">            alpha = <span class="variable language_">self</span>.contrast_slider.value() / <span class="number">100.0</span></span><br><span class="line">            beta = <span class="variable language_">self</span>.brightness_slider.value()</span><br><span class="line">            contrast_img = (saturation_img - mean) * alpha + mean + beta</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 确保像素值在 [0, 255] 范围内</span></span><br><span class="line">            contrast_img = np.clip(contrast_img, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">            </span><br><span class="line">            brightness_img = cv2.convertScaleAbs(contrast_img, alpha=<span class="number">1</span>, beta=<span class="variable language_">self</span>.brightness_slider.value())</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">self</span>.changed_image = brightness_img</span><br><span class="line">            <span class="comment"># images_1 = np.hstack([self.image, saturation_img])</span></span><br><span class="line">            <span class="comment"># images_2 = np.hstack([contrast_img, brightness_img])</span></span><br><span class="line">            <span class="comment"># result_image = np.vstack([images_1, images_2])</span></span><br><span class="line">            <span class="comment">#result_image = np.hstack([self.image,brightness_img])</span></span><br><span class="line">            <span class="comment">#变换后图 </span></span><br><span class="line">            height, width, channel = brightness_img.shape</span><br><span class="line">            bytes_per_line = <span class="number">3</span> * width</span><br><span class="line">            q_image = QImage(brightness_img.data, width, height, bytes_per_line, QImage.Format_BGR888)</span><br><span class="line">            pixmap = QPixmap.fromImage(q_image)</span><br><span class="line">            <span class="variable language_">self</span>.changed_image_label.setPixmap(pixmap)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#原图</span></span><br><span class="line">            height, width, channel = <span class="variable language_">self</span>.image.shape</span><br><span class="line">            bytes_per_line = <span class="number">3</span> * width</span><br><span class="line">            q_image = QImage(<span class="variable language_">self</span>.image.data, width, height, bytes_per_line, QImage.Format_BGR888)</span><br><span class="line">            pixmap = QPixmap.fromImage(q_image)</span><br><span class="line">            <span class="variable language_">self</span>.ori_image_label.setPixmap(pixmap)   </span><br><span class="line">            <span class="comment">#cv2.imshow("image",self.image)</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            QMessageBox.warning(<span class="variable language_">self</span>, <span class="string">"Warning"</span>, <span class="string">"请先上传图片"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_saturation</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.saturation_label.setText(<span class="string">f"Saturation: <span class="subst">{value}</span>%"</span>)</span><br><span class="line">        <span class="variable language_">self</span>.update_image()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_contrast</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.contrast_label.setText(<span class="string">f"Contrast: <span class="subst">{value}</span>%"</span>)</span><br><span class="line">        <span class="variable language_">self</span>.update_image()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_brightness</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.brightness_label.setText(<span class="string">f"Brightness: <span class="subst">{value}</span>%"</span>)</span><br><span class="line">        <span class="variable language_">self</span>.update_image()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.image <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            options = QFileDialog.Options()</span><br><span class="line">            file_name, _ = QFileDialog.getSaveFileName(<span class="variable language_">self</span>, <span class="string">"Save Image"</span>, <span class="string">"changed.jpg"</span>, <span class="string">"Image Files (*.png *.jpg *.bmp)"</span>, options=options)</span><br><span class="line">            <span class="keyword">if</span> file_name:</span><br><span class="line">                cv2.imwrite(file_name, <span class="variable language_">self</span>.changed_image)</span><br><span class="line">                QMessageBox.information(<span class="variable language_">self</span>, <span class="string">"Success"</span>, <span class="string">"图片保存成功"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    main_window = MainWindow()</span><br><span class="line">    main_window.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<h4 id="2、hog特征"><a href="#2、hog特征" class="headerlink" title="2、hog特征"></a>2、hog特征</h4><h5 id="2、1手动实现"><a href="#2、1手动实现" class="headerlink" title="2、1手动实现"></a>2、1手动实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOG</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,img,cell_size=<span class="number">16</span>,bin_size=<span class="number">8</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.img = img</span><br><span class="line">        <span class="variable language_">self</span>.img = cv2.resize(<span class="variable language_">self</span>.img,(<span class="number">224</span>,<span class="number">224</span>))</span><br><span class="line">        <span class="comment"># gamma 矫正</span></span><br><span class="line">        <span class="variable language_">self</span>.img = np.power(<span class="variable language_">self</span>.img/<span class="built_in">float</span>(np.<span class="built_in">max</span>(<span class="variable language_">self</span>.img)),<span class="number">1.5</span>) </span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.cell_size = cell_size</span><br><span class="line">        <span class="variable language_">self</span>.bin_size = bin_size</span><br><span class="line">        <span class="variable language_">self</span>.angle_range = <span class="number">360</span>/<span class="variable language_">self</span>.bin_size</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grad_and_theta</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#dx</span></span><br><span class="line">        kernel_x = np.array([[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">        <span class="comment">#dx = cv2.filter2D(self.img, -1, kernel_x)</span></span><br><span class="line">        dx = signal.convolve2d(<span class="variable language_">self</span>.img,kernel_x,boundary=<span class="string">'symm'</span>,mode=<span class="string">'same'</span>)</span><br><span class="line">        <span class="comment">#dy</span></span><br><span class="line">        kernel_y = np.array([[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]).T</span><br><span class="line">        <span class="comment">#dy = cv2.filter2D(self.img, -1, kernel_y)</span></span><br><span class="line">        dy = signal.convolve2d(<span class="variable language_">self</span>.img,kernel_y,boundary=<span class="string">'symm'</span>,mode=<span class="string">'same'</span>)</span><br><span class="line">        <span class="comment">#grad</span></span><br><span class="line">        grad  = np.sqrt(dx**<span class="number">2</span>+dy**<span class="number">2</span>)</span><br><span class="line">        <span class="comment">#angle</span></span><br><span class="line">        theta = np.degrees(np.arctan2(dx,dy))</span><br><span class="line">        <span class="comment">#处理theta小于0</span></span><br><span class="line">        theta[theta&lt;<span class="number">0</span>] = np.pi+theta[theta&lt;<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grad,theta</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cell_hist</span>(<span class="params">self,grad,theta</span>):</span><br><span class="line">        <span class="comment">#初始化</span></span><br><span class="line">        cell_hist = <span class="variable language_">self</span>.bin_size*[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(grad.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(grad.shape[<span class="number">1</span>]):</span><br><span class="line">                index = <span class="built_in">int</span>(theta[i][j]/<span class="variable language_">self</span>.angle_range)</span><br><span class="line">                rest = theta[i][j]%<span class="variable language_">self</span>.angle_range</span><br><span class="line">                <span class="keyword">if</span> rest==<span class="number">0</span>:</span><br><span class="line">                    cell_hist[index] += grad[i][j]</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    <span class="comment">#计算一个比例</span></span><br><span class="line">                    cell_hist[index] += grad[i][j]*(<span class="number">1</span>-rest/<span class="variable language_">self</span>.angle_range)</span><br><span class="line">                    cell_hist[(index+<span class="number">1</span>)%<span class="variable language_">self</span>.bin_size] += grad[i][j]*(rest/<span class="variable language_">self</span>.angle_range)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cell_hist   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">#整张图片的特征</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">block_hist</span>(<span class="params">self,grad,theta</span>):</span><br><span class="line">        height,width = <span class="variable language_">self</span>.img.shape</span><br><span class="line">        cell_grad_vec = np.zeros((<span class="built_in">int</span>(height/<span class="variable language_">self</span>.cell_size),<span class="built_in">int</span>(width/<span class="variable language_">self</span>.cell_size),<span class="variable language_">self</span>.bin_size))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cell_grad_vec.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cell_grad_vec.shape[<span class="number">1</span>]):</span><br><span class="line">                cell_grad_t = grad[i*<span class="variable language_">self</span>.cell_size:(i+<span class="number">1</span>)*<span class="variable language_">self</span>.cell_size,j*<span class="variable language_">self</span>.cell_size:(j+<span class="number">1</span>)*<span class="variable language_">self</span>.cell_size]</span><br><span class="line">                cell_theta_t = theta[i*<span class="variable language_">self</span>.cell_size:(i+<span class="number">1</span>)*<span class="variable language_">self</span>.cell_size,j*<span class="variable language_">self</span>.cell_size:(j+<span class="number">1</span>)*<span class="variable language_">self</span>.cell_size]</span><br><span class="line">                cell_grad_vec[i][j] = <span class="variable language_">self</span>.cell_hist(cell_grad_t,cell_theta_t)</span><br><span class="line">        </span><br><span class="line">        hog_image = <span class="variable language_">self</span>.render_gradient(np.zeros(<span class="variable language_">self</span>.img.shape),cell_grad_vec)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hog_image</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#画图</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">render_gradient</span>(<span class="params">self, image, cell_gradient</span>):</span><br><span class="line">        cell_width = <span class="variable language_">self</span>.cell_size / <span class="number">2</span></span><br><span class="line">        max_mag = np.array(cell_gradient).<span class="built_in">max</span>()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(cell_gradient.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(cell_gradient.shape[<span class="number">1</span>]):</span><br><span class="line">                cell_grad = cell_gradient[x][y]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 归一化</span></span><br><span class="line">                cell_grad /= max_mag</span><br><span class="line">                angle = <span class="number">0</span></span><br><span class="line">                angle_gap = <span class="variable language_">self</span>.angle_range</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> magnitude <span class="keyword">in</span> cell_grad:</span><br><span class="line">                    angle_radian = math.radians(angle)</span><br><span class="line">                    x1 = <span class="built_in">int</span>(x * <span class="variable language_">self</span>.cell_size + magnitude * cell_width * math.cos(angle_radian))</span><br><span class="line">                    y1 = <span class="built_in">int</span>(y * <span class="variable language_">self</span>.cell_size + magnitude * cell_width * math.sin(angle_radian))</span><br><span class="line">                    x2 = <span class="built_in">int</span>(x * <span class="variable language_">self</span>.cell_size - magnitude * cell_width * math.cos(angle_radian))</span><br><span class="line">                    y2 = <span class="built_in">int</span>(y * <span class="variable language_">self</span>.cell_size - magnitude * cell_width * math.sin(angle_radian))</span><br><span class="line">                    </span><br><span class="line">                    cv2.line(image, (y1, x1), (y2, x2), <span class="built_in">int</span>(<span class="number">255</span> * math.sqrt(magnitude)))</span><br><span class="line">                    </span><br><span class="line">                    angle += angle_gap</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">"pic/sky1.jpg"</span>,<span class="number">0</span>)</span><br><span class="line">    hog = HOG(img,<span class="number">16</span>,<span class="number">8</span>)</span><br><span class="line">    grad, theta = hog.grad_and_theta()</span><br><span class="line">    <span class="built_in">print</span>(grad.shape[<span class="number">0</span>],theta.shape)</span><br><span class="line">    image = hog.block_hist(grad, theta)</span><br><span class="line">    </span><br><span class="line">    fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">    ax1.axis(<span class="string">'off'</span>)</span><br><span class="line">    ax1.imshow(img, cmap=plt.cm.gray)</span><br><span class="line">    ax1.set_title(<span class="string">'Input image'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Rescale histogram for better display</span></span><br><span class="line">    hog_image_rescaled = exposure.rescale_intensity(image, in_range=(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">    ax2.axis(<span class="string">'off'</span>)</span><br><span class="line">    ax2.imshow(hog_image_rescaled, cmap=plt.cm.gray)</span><br><span class="line">    ax2.set_title(<span class="string">'Histogram of Oriented Gradients'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2、2库函数"><a href="#2、2库函数" class="headerlink" title="2、2库函数"></a>2、2库函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> data, exposure</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">'pic/sky1.jpg'</span>, <span class="number">0</span>)        <span class="comment"># 读取图片，有0的话表示转变为灰度图；</span></span><br><span class="line">image = cv2.resize(image, (<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">image = np.float32(image) / <span class="number">255.0</span>       <span class="comment"># 归一化</span></span><br><span class="line"><span class="comment"># cv2.imshow("normalization",image)</span></span><br><span class="line"><span class="comment"># cv2.waitKey()</span></span><br><span class="line"></span><br><span class="line">fd, hog_image = hog(image,</span><br><span class="line">                    orientations=<span class="number">8</span>,</span><br><span class="line">                    pixels_per_cell=(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">                    cells_per_block=(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">                    visualize=<span class="literal">True</span>,</span><br><span class="line">                    ) <span class="comment"># multichannel=True是针对3通道彩色；</span></span><br><span class="line"></span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">ax1.axis(<span class="string">'off'</span>)</span><br><span class="line">ax1.imshow(image, cmap=plt.cm.gray)</span><br><span class="line">ax1.set_title(<span class="string">'Input image'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rescale histogram for better display</span></span><br><span class="line">hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">ax2.axis(<span class="string">'off'</span>)</span><br><span class="line">ax2.imshow(hog_image_rescaled, cmap=plt.cm.gray)</span><br><span class="line">ax2.set_title(<span class="string">'Histogram of Oriented Gradients'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h5 id="2、3-hog-SVM"><a href="#2、3-hog-SVM" class="headerlink" title="2、3 hog+SVM"></a>2、3 hog+SVM</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gzip <span class="comment">#解压</span></span><br><span class="line"><span class="keyword">import</span> certifi</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_mnist_images</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(filename,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = np.frombuffer(f.read(),np.uint8,offset=<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> data.reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_mnist_labels</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(filename,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = np.frombuffer(f.read(),np.uint8,offset=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">HOG</span>(<span class="params">images</span>):</span><br><span class="line">    hog = cv2.HOGDescriptor((<span class="number">28</span>,<span class="number">28</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">4</span>),<span class="number">9</span>) <span class="comment">#winSize, blockSize, blockStride, cellSize, nbins, derivAperture=1, winSigma=-1, histogramNormType=0, L2HysThreshold=0.2, gammaCorrection=1, nlevels=64, signedGradient=False</span></span><br><span class="line">    <span class="comment">#gray_images = cv2.cvtColor(images,cv2.COLOR_BGR2GRAY)</span></span><br><span class="line">    hog_image=[]</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">        feature = hog.compute(image)</span><br><span class="line">        hog_image.append(feature.flatten())</span><br><span class="line">    <span class="keyword">return</span> np.array(hog_image)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">svm_model</span>():</span><br><span class="line">    </span><br><span class="line">    model = cv2.ml.SVM_create()</span><br><span class="line">    model.setGamma(<span class="number">0.1</span>)<span class="comment">#核函数宽度</span></span><br><span class="line">    model.setC(<span class="number">10</span>)<span class="comment">#误差项的惩罚系数</span></span><br><span class="line">    model.setKernel(cv2.ml.SVM_RBF)<span class="comment">#将数据映射到高维</span></span><br><span class="line">    model.setType(cv2.ml.SVM_C_SVC)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 MNIST 数据集</span></span><br><span class="line">x_train = load_mnist_images(<span class="string">'train-images-idx3-ubyte.gz'</span>)</span><br><span class="line">y_train = load_mnist_labels(<span class="string">'train-labels-idx1-ubyte.gz'</span>)</span><br><span class="line">x_test = load_mnist_images(<span class="string">'t10k-images-idx3-ubyte.gz'</span>)</span><br><span class="line">y_test = load_mnist_labels(<span class="string">'t10k-labels-idx1-ubyte.gz'</span>)</span><br><span class="line"></span><br><span class="line">x_train_hog = HOG(x_train)</span><br><span class="line">x_test_hog = HOG(x_test)</span><br><span class="line"></span><br><span class="line">x_train_hog = x_train_hog.astype(<span class="string">'float32'</span>)</span><br><span class="line">x_test_hog = x_test_hog.astype(<span class="string">'float32'</span>)</span><br><span class="line">y_train = y_train.astype(<span class="string">'int32'</span>)</span><br><span class="line">y_test = y_test.astype(<span class="string">'int32'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"data ready"</span>)</span><br><span class="line"></span><br><span class="line">SVM = svm_model()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"SVM created"</span>)</span><br><span class="line">SVM.train(x_train_hog,cv2.ml.ROW_SAMPLE,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"SVM trained"</span>)</span><br><span class="line"></span><br><span class="line">SVM.save(<span class="string">'svm_model.xml'</span>)</span><br><span class="line"></span><br><span class="line">_,y_pred = SVM.predict(x_test_hog)</span><br><span class="line">y_pred = y_pred.flatten().astype(<span class="string">'int32'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"prediction done"</span>)</span><br><span class="line"></span><br><span class="line">acc = np.<span class="built_in">sum</span>(y_pred==y_test)/<span class="built_in">len</span>(y_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Accuracy: "</span>,acc)</span><br><span class="line"></span><br><span class="line"><span class="comment">#blockSize, blockStride, cellSize =(4,4) gamma=0.1 C=120  0.989</span></span><br><span class="line"><span class="comment">#blockSize, blockStride, cellSize =(4,4) gamma=0.1 C=100  0.989</span></span><br><span class="line"><span class="comment">#blockSize, blockStride, cellSize =(4,4) gamma=0.1 C=1  0.9884</span></span><br><span class="line"><span class="comment">#blockSize, blockStride, cellSize =(4,4) gamma=0.03 C=100 0.9875</span></span><br><span class="line"><span class="comment">#blockSize, blockStride, cellSize =(4,4) gamma=0.01 C=100 0.9845</span></span><br><span class="line"><span class="comment">#blockSize, blockStride, cellSize =(2,2) gamma=0.1 C=1 0.9821</span></span><br><span class="line"><span class="comment">#blockSize, blockStride, cellSize =(4,4) gamma=0.0 C=100 SVM_LINEAR 0.9667 </span></span><br><span class="line"><span class="comment">#blockSize, blockStride, cellSize =(7,7) gamma=0.03 C=100 0.9697</span></span><br></pre></td></tr></table></figure>
<h4 id="3、直方图相似性匹配"><a href="#3、直方图相似性匹配" class="headerlink" title="3、直方图相似性匹配"></a>3、直方图相似性匹配</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># def cos(image1,image2):</span></span><br><span class="line"><span class="comment">#     images = [image1,image2]</span></span><br><span class="line"><span class="comment">#     vectors=[]</span></span><br><span class="line"><span class="comment">#     norms=[]</span></span><br><span class="line"><span class="comment">#     for image in images:</span></span><br><span class="line"><span class="comment">#         vector = []</span></span><br><span class="line"><span class="comment">#         for pix in image:</span></span><br><span class="line"><span class="comment">#             vector.append(np.average(pix))</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">#             vector.append(vector)</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">#         vectors.append(vector)    </span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         norms.append(np.linalg.norm(vector))</span></span><br><span class="line"><span class="comment">#     img1_vec,img2_vec = vectors    </span></span><br><span class="line"><span class="comment">#     image1_norm,image2_norm=norms</span></span><br><span class="line"><span class="comment">#     return np.dot(img1_vec/image1_norm,img2_vec/image2_norm)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_hist</span>(<span class="params">channel</span>):</span><br><span class="line">    </span><br><span class="line">    hist =[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">    </span><br><span class="line">    w,d=channel.shape</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">            hist[channel[i][j]]+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> hist</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image_hist</span>(<span class="params">image</span>):</span><br><span class="line">    image = cv2.resize(image,(<span class="number">256</span>,<span class="number">256</span>))</span><br><span class="line">    hists=[]</span><br><span class="line">    b_channel,g_channel,r_channel = cv2.split(image)</span><br><span class="line">    b_hist = cal_hist(b_channel)</span><br><span class="line">    g_hist = cal_hist(g_channel)</span><br><span class="line">    r_hist = cal_hist(r_channel)</span><br><span class="line">    hists.append(b_hist)</span><br><span class="line">    hists.append(g_hist)</span><br><span class="line">    hists.append(r_hist)</span><br><span class="line">    <span class="keyword">return</span> hists</span><br><span class="line"></span><br><span class="line"><span class="comment">#用的是归一化之后的欧氏距离进行直方图相似度计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_simility</span>(<span class="params">hist1,hist2</span>):</span><br><span class="line">    degrees=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        degree = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> hist1[i][j]==hist2[i][j]:</span><br><span class="line">                degree+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                degree+= (<span class="number">1</span>-(<span class="built_in">abs</span>(hist1[i][j]-hist2[i][j])/<span class="built_in">max</span>(hist1[i][j],hist2[i][j])))</span><br><span class="line">        degrees += degree /<span class="number">256</span></span><br><span class="line">    </span><br><span class="line">    degrees/=<span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> degrees          </span><br><span class="line"></span><br><span class="line">image1 = cv2.imread(<span class="string">"pic/sky3.jpg"</span>)</span><br><span class="line">image1_hist = image_hist(image1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取pic文件夹中图片文件</span></span><br><span class="line">path = <span class="string">"pic"</span></span><br><span class="line">images = []</span><br><span class="line">degrees = []</span><br><span class="line">image_paths = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image_name <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">    pic_path = os.path.join(path, image_name)</span><br><span class="line">    image = cv2.imread(pic_path)</span><br><span class="line">    image = cv2.resize(image,(<span class="number">256</span>,<span class="number">256</span>))</span><br><span class="line">    image_hist_ = image_hist(image)</span><br><span class="line">    degree = cal_simility(image1_hist, image_hist_)</span><br><span class="line">    images.append(image)</span><br><span class="line">    degrees.append(degree)</span><br><span class="line">    image_paths.append(pic_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对图片和相似度进行排序</span></span><br><span class="line">sorted_indices = np.argsort(degrees)[::-<span class="number">1</span>]  <span class="comment"># 从高到低排序</span></span><br><span class="line">sorted_images = [images[i] <span class="keyword">for</span> i <span class="keyword">in</span> sorted_indices]</span><br><span class="line">sorted_degrees = [degrees[i] <span class="keyword">for</span> i <span class="keyword">in</span> sorted_indices]</span><br><span class="line">sorted_image_paths = [image_paths[i] <span class="keyword">for</span> i <span class="keyword">in</span> sorted_indices]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有图片显示出来，并标明相似度</span></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">num_images = <span class="built_in">len</span>(sorted_images)</span><br><span class="line">rows = <span class="built_in">int</span>(np.ceil(num_images / <span class="number">3</span>))  <span class="comment"># 每行显示3张图片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_images):</span><br><span class="line">    plt.subplot(rows, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(cv2.cvtColor(sorted_images[i], cv2.COLOR_BGR2RGB))</span><br><span class="line">    plt.title(<span class="string">f"<span class="subst">{os.path.basename(sorted_image_paths[i])}</span>\nSimilarity: <span class="subst">{sorted_degrees[i]:<span class="number">.2</span>f}</span>"</span>)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h4 id="三层全连接推导"><a href="#三层全连接推导" class="headerlink" title="三层全连接推导"></a>三层全连接推导</h4><img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/12.png" class="" title="img">
<h4 id="代码实现：GTP4o-version"><a href="#代码实现：GTP4o-version" class="headerlink" title="代码实现：GTP4o version"></a>代码实现：GTP4o version</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">w1, w2, w3, w4 = <span class="number">0.15</span>, <span class="number">0.20</span>, <span class="number">0.25</span>, <span class="number">0.30</span></span><br><span class="line">w5, w6, w7, w8 = <span class="number">0.40</span>, <span class="number">0.45</span>, <span class="number">0.50</span>, <span class="number">0.55</span></span><br><span class="line">b1, b2 = <span class="number">0.35</span>, <span class="number">0.60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入和目标输出</span></span><br><span class="line">x = np.array([<span class="number">0.05</span>, <span class="number">0.10</span>])</span><br><span class="line">y_true = np.array([<span class="number">0.01</span>, <span class="number">0.99</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid_derivative</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">return</span> sigmoid(z) * (<span class="number">1</span> - sigmoid(z))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向传播</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward_propagation</span>(<span class="params">x, w, b</span>):</span><br><span class="line">    <span class="comment"># 隐藏层</span></span><br><span class="line">    z1 = x[<span class="number">0</span>] * w[<span class="number">0</span>] + x[<span class="number">1</span>] * w[<span class="number">1</span>] + b[<span class="number">0</span>]</span><br><span class="line">    z2 = x[<span class="number">0</span>] * w[<span class="number">2</span>] + x[<span class="number">1</span>] * w[<span class="number">3</span>] + b[<span class="number">0</span>]</span><br><span class="line">    h1 = sigmoid(z1)</span><br><span class="line">    h2 = sigmoid(z2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出层</span></span><br><span class="line">    z3 = h1 * w[<span class="number">4</span>] + h2 * w[<span class="number">5</span>] + b[<span class="number">1</span>]</span><br><span class="line">    z4 = h1 * w[<span class="number">6</span>] + h2 * w[<span class="number">7</span>] + b[<span class="number">1</span>]</span><br><span class="line">    o1 = sigmoid(z3)</span><br><span class="line">    o2 = sigmoid(z4)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array([h1, h2]), np.array([o1, o2]), np.array([z1, z2, z3, z4])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向传播</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backpropagation</span>(<span class="params">x, y_true, hidden_output, output, intermediate_z, w, b, lr</span>):</span><br><span class="line">    <span class="comment"># 输出层误差</span></span><br><span class="line">    delta_o1 = (output[<span class="number">0</span>] - y_true[<span class="number">0</span>]) * sigmoid_derivative(intermediate_z[<span class="number">2</span>])</span><br><span class="line">    delta_o2 = (output[<span class="number">1</span>] - y_true[<span class="number">1</span>]) * sigmoid_derivative(intermediate_z[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐藏层误差</span></span><br><span class="line">    delta_h1 = (delta_o1 * w[<span class="number">4</span>] + delta_o2 * w[<span class="number">6</span>]) * sigmoid_derivative(intermediate_z[<span class="number">0</span>])</span><br><span class="line">    delta_h2 = (delta_o1 * w[<span class="number">5</span>] + delta_o2 * w[<span class="number">7</span>]) * sigmoid_derivative(intermediate_z[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新权重</span></span><br><span class="line">    w[<span class="number">4</span>] -= lr * delta_o1 * hidden_output[<span class="number">0</span>]</span><br><span class="line">    w[<span class="number">5</span>] -= lr * delta_o1 * hidden_output[<span class="number">1</span>]</span><br><span class="line">    w[<span class="number">6</span>] -= lr * delta_o2 * hidden_output[<span class="number">0</span>]</span><br><span class="line">    w[<span class="number">7</span>] -= lr * delta_o2 * hidden_output[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    w[<span class="number">0</span>] -= lr * delta_h1 * x[<span class="number">0</span>]</span><br><span class="line">    w[<span class="number">1</span>] -= lr * delta_h1 * x[<span class="number">1</span>]</span><br><span class="line">    w[<span class="number">2</span>] -= lr * delta_h2 * x[<span class="number">0</span>]</span><br><span class="line">    w[<span class="number">3</span>] -= lr * delta_h2 * x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新偏置</span></span><br><span class="line">    b[<span class="number">1</span>] -= lr * (delta_o1 + delta_o2)</span><br><span class="line">    b[<span class="number">0</span>] -= lr * (delta_h1 + delta_h2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化权重和偏置</span></span><br><span class="line">w = np.array([w1, w2, w3, w4, w5, w6, w7, w8])</span><br><span class="line">b = np.array([b1, b2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line">lr = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练循环</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    hidden_output, output, intermediate_z = forward_propagation(x, w, b)</span><br><span class="line">    loss = <span class="number">0.5</span> * ((y_true[<span class="number">0</span>] - output[<span class="number">0</span>])**<span class="number">2</span> + (y_true[<span class="number">1</span>] - output[<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"Epoch <span class="subst">{epoch}</span>, Loss: <span class="subst">{loss:<span class="number">.6</span>f}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    w, b = backpropagation(x, y_true, hidden_output, output, intermediate_z, w, b, lr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终结果</span></span><br><span class="line">hidden_output, output, _ = forward_propagation(x, w, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"训练完成后:"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"隐藏层输出: h1 = {:.4f}, h2 = {:.4f}"</span>.<span class="built_in">format</span>(hidden_output[<span class="number">0</span>], hidden_output[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"输出层输出: o1 = {:.4f}, o2 = {:.4f}"</span>.<span class="built_in">format</span>(output[<span class="number">0</span>], output[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p><strong>卷积计算公式：<script type="math/tex">(N + 2P - K) / S + 1</script></strong></p>
<img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/5.png" class="" title="img">
<p>输出尺寸：（32+2 x 2-5）/1+1=32+4-5+1=32</p>
<p>参数量：10个5x5卷积核，维度为3，10x5x5x3=750，还有10个偏置，共760个参数</p>
<img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/6.png" class="" title="img">
<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><p>转置卷积公式：<script type="math/tex">outputsize = (inputsize - 1) * stride + kernelsize - 2*padding</script></p>
<img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/7.png" class="" title="img">
<script type="math/tex; mode=display">(7-1)*2+3-2*1=13,卷积个数为8</script><img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/8.png" class="" title="img">
<p>答案错了</p>
<script type="math/tex; mode=display">(4-1)*2+4-2*1=8,答案是C</script><img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/9.png" class="" title="img">
<h4 id="RCNN-Region-based-Convolutional-Neural-Networks"><a href="#RCNN-Region-based-Convolutional-Neural-Networks" class="headerlink" title="RCNN (Region-based Convolutional Neural Networks)"></a>RCNN (Region-based Convolutional Neural Networks)</h4><ol>
<li><strong>选择候选区域</strong>：使用选择性搜索（Selective Search）算法生成大约 2000 个候选区域（Region Proposals）。</li>
<li><strong>特征提取</strong>：将每个候选区域调整为固定大小，并使用卷积神经网络（CNN）提取特征。</li>
<li><strong>分类和回归</strong>：使用支持向量机（SVM）对每个候选区域进行分类，并使用线性回归调整边界框。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ul>
<li>计算量大，速度慢，因为每个候选区域都需要单独通过 CNN 进行特征提取。</li>
<li>存储需求高，因为需要存储每个候选区域的特征。</li>
</ul>
<h4 id="Fast-RCNN"><a href="#Fast-RCNN" class="headerlink" title="Fast RCNN"></a>Fast RCNN</h4><ol>
<li><strong>共享特征提取</strong>：整个图像通过 CNN 进行一次特征提取，生成特征图。</li>
<li><strong>候选区域生成</strong>：在特征图上使用选择性搜索生成候选区域。</li>
<li><strong>ROI Pooling</strong>：将候选区域映射到特征图上，并使用 ROI Pooling 层将不同大小的候选区域调整为相同大小。</li>
<li><strong>分类和回归</strong>：使用全连接层对每个候选区域进行分类和边界框回归。</li>
</ol>
<p><strong>改进</strong>：</p>
<ul>
<li>通过共享特征提取，大大减少了计算量，提高了速度。</li>
<li>使用 ROI Pooling 层，使得不同大小的候选区域可以在同一个特征图上进行处理。</li>
</ul>
<h4 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster RCNN"></a>Faster RCNN</h4><ol>
<li><strong>共享特征提取</strong>：整个图像通过 CNN 进行一次特征提取，生成特征图。</li>
<li><strong>区域建议网络（RPN）</strong>：在特征图上使用 RPN 生成候选区域。RPN 是一个轻量级网络，可以直接在特征图上生成候选区域。</li>
<li><strong>ROI Pooling</strong>：将 RPN 生成的候选区域映射到特征图上，并使用 ROI Pooling 层将不同大小的候选区域调整为相同大小。</li>
<li><strong>分类和回归</strong>：使用全连接层对每个候选区域进行分类和边界框回归。</li>
</ol>
<p><strong>改进</strong>：</p>
<ul>
<li>引入 RPN 代替选择性搜索，进一步提高了候选区域生成的速度和质量。</li>
<li>RPN 和 Fast RCNN 共享特征提取网络，使得整个网络可以端到端训练，提高了检测精度和速度。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>RCNN</strong>：使用选择性搜索生成候选区域，每个候选区域单独通过 CNN 提取特征，速度慢。</li>
<li><strong>Fast RCNN</strong>：共享特征提取，使用 ROI Pooling 层处理候选区域，提高了速度。</li>
<li><strong>Faster RCNN</strong>：引入 RPN 生成候选区域，进一步提高了速度和精度，实现了端到端训练。</li>
</ul>
<h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><h4 id="CBIR："><a href="#CBIR：" class="headerlink" title="CBIR："></a>CBIR：</h4><p>大规模图像集的基于内容的图像检索（Content-Based Image Retrieval，简称 CBIR）是一种利用图像的视觉内容（如颜色、纹理、形状等）进行图像检索的方法。与基于文本的图像检索不同，CBIR 不依赖于图像的元数据（如标签、描述），而是直接分析图像的内容来进行检索。</p>
<h4 id="CBIR-的基本原理"><a href="#CBIR-的基本原理" class="headerlink" title="CBIR 的基本原理"></a>CBIR 的基本原理</h4><ol>
<li><strong>特征提取</strong>：从图像中提取视觉特征，如颜色直方图、纹理特征、形状特征等。这些特征通常以向量的形式表示。</li>
<li><strong>特征索引</strong>：将提取的特征存储在数据库中，并建立索引，以便快速检索。</li>
<li><strong>相似性度量</strong>：定义一种度量图像特征相似性的算法，如欧氏距离、余弦相似度等。</li>
<li><strong>检索过程</strong><ul>
<li>用户提供查询图像。</li>
<li>从查询图像中提取特征。</li>
<li>计算查询图像特征与数据库中图像特征之间的相似性。</li>
<li>返回与查询图像最相似的图像。</li>
</ul>
</li>
</ol>
<h4 id="向量检索"><a href="#向量检索" class="headerlink" title="向量检索"></a>向量检索</h4><p>向量检索（Vector Retrieval）是一种基于向量空间模型的检索方法，用于在高维向量空间中查找与查询向量相似的向量。向量检索广泛应用于信息检索、推荐系统、图像检索、自然语言处理等领域。</p>
<p>向量检索是一种基于向量空间模型的检索方法，通过将数据转换为向量表示，并使用相似性度量和高效的索引结构，快速查找与查询向量相似的向量。向量检索在信息检索、推荐系统、图像检索等领域有广泛的应用。</p>
<h5 id="向量检索的基本原理"><a href="#向量检索的基本原理" class="headerlink" title="向量检索的基本原理"></a>向量检索的基本原理</h5><ol>
<li><strong>特征表示</strong>：将数据（如文本、图像、音频等）转换为向量表示。例如，文本可以通过词嵌入（如 Word2Vec、GloVe、BERT）转换为向量，图像可以通过卷积神经网络（CNN）提取特征向量。</li>
<li><strong>相似性度量</strong>：定义一种度量向量之间相似性的方法。常用的相似性度量包括欧氏距离、余弦相似度、曼哈顿距离等。</li>
<li><strong>索引结构</strong>：构建高效的索引结构，以便快速检索相似向量。常用的索引结构包括 KD 树、球树（Ball Tree）、局部敏感哈希（LSH）、近似最近邻（ANN）等。</li>
<li><strong>检索过程</strong><ul>
<li>用户提供查询向量。</li>
<li>计算查询向量与数据库中向量的相似性。</li>
<li>返回与查询向量最相似的向量。</li>
</ul>
</li>
</ol>
<h5 id="向量检索的应用场景"><a href="#向量检索的应用场景" class="headerlink" title="向量检索的应用场景"></a>向量检索的应用场景</h5><ol>
<li><strong>信息检索</strong>：在文档库中查找与查询文本相似的文档。</li>
<li><strong>推荐系统</strong>：根据用户的历史行为向量，推荐相似的物品。</li>
<li><strong>图像检索</strong>：在图像库中查找与查询图像相似的图像。</li>
<li><strong>自然语言处理</strong>：在语料库中查找与查询句子相似的句子。</li>
<li><strong>音频检索</strong>：在音频库中查找与查询音频相似的音频。</li>
</ol>
<h4 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h4><p>向量数据库（Vector Database）是一种专门用于存储、索引和检索高维向量数据的数据库系统。随着机器学习和深度学习的发展，向量数据库在处理和管理大规模向量数据方面变得越来越重要。向量数据库通常用于支持基于内容的检索、推荐系统、图像和文本搜索等应用。</p>
<p>向量数据库是一种专门用于存储、索引和检索高维向量数据的数据库系统，广泛应用于图像检索、文本检索、推荐系统等领域。通过使用高效的索引结构和相似性搜索算法，向量数据库能够在大规模数据中快速查找与查询向量相似的向量。</p>
<h5 id="向量数据库的特点"><a href="#向量数据库的特点" class="headerlink" title="向量数据库的特点"></a>向量数据库的特点</h5><ol>
<li><strong>高维数据存储</strong>：能够高效地存储和管理高维向量数据。</li>
<li><strong>相似性搜索</strong>：支持快速的相似性搜索，通常使用近似最近邻（Approximate Nearest Neighbor, ANN）算法。</li>
<li><strong>高效索引</strong>：使用高效的索引结构（如 KD 树、球树、LSH 等）来加速向量检索。</li>
<li><strong>扩展性</strong>：能够处理大规模数据，支持分布式存储和计算。</li>
<li><strong>实时性</strong>：支持实时数据插入、更新和删除操作。</li>
</ol>
<h5 id="向量数据库的应用场景"><a href="#向量数据库的应用场景" class="headerlink" title="向量数据库的应用场景"></a>向量数据库的应用场景</h5><ol>
<li><strong>图像检索</strong>：在大规模图像库中查找与查询图像相似的图像。</li>
<li><strong>文本检索</strong>：在文档库中查找与查询文本相似的文档。</li>
<li><strong>推荐系统</strong>：根据用户的历史行为向量，推荐相似的物品。</li>
<li><strong>音频检索</strong>：在音频库中查找与查询音频相似的音频。</li>
<li><strong>生物信息学</strong>：在基因序列库中查找相似的基因序列。</li>
</ol>
<h5 id="常见的向量数据库"><a href="#常见的向量数据库" class="headerlink" title="常见的向量数据库"></a>常见的向量数据库</h5><ol>
<li><strong>Faiss</strong>：由 Facebook AI Research 开发的高效相似性搜索库，支持大规模向量数据的快速检索。</li>
<li><strong>Annoy</strong>：由 Spotify 开发的近似最近邻搜索库，适用于内存中的大规模数据。</li>
<li><strong>Milvus</strong>：一个开源的向量数据库，支持大规模向量数据的存储和检索，具有高扩展性和高性能。</li>
<li><strong>Elasticsearch with k-NN plugin</strong>：Elasticsearch 是一个分布式搜索引擎，k-NN 插件支持向量相似性搜索。</li>
</ol>
<img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/10.png" class="" title="img">
<h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><h4 id="权值：标量（浮点数），本意是体现相关性，或者说依赖关系，一般通过-两个向量点乘得到（但不是直接点乘（相似性），而是乘以一个转换矩阵-后，而且转换后的维度可能发生变化，Why？）"><a href="#权值：标量（浮点数），本意是体现相关性，或者说依赖关系，一般通过-两个向量点乘得到（但不是直接点乘（相似性），而是乘以一个转换矩阵-后，而且转换后的维度可能发生变化，Why？）" class="headerlink" title="权值：标量（浮点数），本意是体现相关性，或者说依赖关系，一般通过 两个向量点乘得到（但不是直接点乘（相似性），而是乘以一个转换矩阵 后，而且转换后的维度可能发生变化，Why？）"></a>权值：标量（浮点数），本意是体现相关性，或者说依赖关系，一般通过 两个向量点乘得到（但不是直接点乘（相似性），而是乘以一个转换矩阵 后，而且转换后的维度可能发生变化，Why？）</h4><p>这些转换矩阵的作用是将输入向量映射到不同的空间，以便更好地捕捉和表示相关性。</p>
<ol>
<li><strong>捕捉不同的特征</strong>：通过使用不同的权重矩阵 (W_Q)、(W_K) 和 (W_V)，可以将输入向量映射到不同的特征空间，从而捕捉输入序列中不同的特征和关系。这使得模型能够更好地理解和表示输入数据的复杂性。</li>
<li><strong>提高模型的表达能力</strong>：线性变换可以增加模型的表达能力，使其能够学习到更复杂的模式和关系。不同的线性变换可以捕捉到输入数据的不同方面，从而提高模型的性能。</li>
<li><p><strong>维度变化</strong>：通过线性变换，可以改变输入向量的维度，以适应不同层的需求。例如，在多头注意力机制中，每个头的维度通常较小，通过线性变换可以将输入向量分割成多个头，每个头独立计算注意力。</p>
<script type="math/tex; mode=display">\text{Attention}(Q, K, V) = \text{Softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right) V</script></li>
</ol>
<h4 id="自注意力-●加权求和得到最终结果，但加-的是Value（同样需要转换矩-阵将输入转换成v），为什么-不能直接加输入-a-？"><a href="#自注意力-●加权求和得到最终结果，但加-的是Value（同样需要转换矩-阵将输入转换成v），为什么-不能直接加输入-a-？" class="headerlink" title="自注意力 ●加权求和得到最终结果，但加 的是Value（同样需要转换矩 阵将输入转换成v），为什么 不能直接加输入 a ？"></a>自注意力 ●加权求和得到最终结果，但加 的是Value（同样需要转换矩 阵将输入转换成v），为什么 不能直接加输入 a ？</h4><p>这是因为自注意力机制的设计目的是通过查询向量（Query）和键向量（Key）计算注意力权重，然后使用这些权重对值向量（Value）进行加权求和，从而生成新的表示。这种设计有几个重要的原因：</p>
<h5 id="1-不同的特征空间"><a href="#1-不同的特征空间" class="headerlink" title="1. 不同的特征空间"></a>1. 不同的特征空间</h5><p>在自注意力机制中，输入向量 (X) 被分别映射到查询向量 (Q)、键向量 (K) 和值向量 (V) 的不同特征空间。这些特征空间的设计目的是为了捕捉输入数据的不同方面：</p>
<ul>
<li><strong>查询向量 (Q)</strong>：用于计算与其他输入向量的相似性。</li>
<li><strong>键向量 (K)</strong>：用于计算与查询向量的相似性。</li>
<li><strong>值向量 (V)</strong>：用于生成最终的输出表示。</li>
</ul>
<p>通过这种方式，模型可以更灵活地学习和表示输入数据的不同特征。如果直接使用输入向量 (X) 进行加权求和，模型将无法充分利用这些不同的特征空间。</p>
<h5 id="2-提高模型的表达能力"><a href="#2-提高模型的表达能力" class="headerlink" title="2. 提高模型的表达能力"></a>2. 提高模型的表达能力</h5><p>通过将输入向量 (X) 映射到值向量 (V)，模型可以学习到更复杂的特征表示。值向量 (V) 可以包含输入向量 (X) 的不同方面的信息，从而提高模型的表达能力和性能。</p>
<h5 id="3-保持一致性"><a href="#3-保持一致性" class="headerlink" title="3. 保持一致性"></a>3. 保持一致性</h5><p>在自注意力机制中，查询向量 (Q) 和键向量 (K) 用于计算注意力权重，而值向量 (V) 用于生成最终的输出表示。这种设计保持了一致性，使得注意力权重可以直接应用于值向量 (V)，从而生成新的表示。如果直接使用输入向量 (X)，将破坏这种一致性。</p>
<img src="/%E6%95%B0%E5%AA%92%E6%B3%A8%E6%84%8F%E7%82%B9.md/11.png" class="" title="img">
<h3 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h3><h4 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h4><p>卷积神经网络（CNN）：</p>
<p>使用CNN模型（如VGGFace、FaceNet）进行人脸特征提取。通过训练大量人脸图像，模型能够学习到不同人脸的独特特征。</p>
<p>应用示例：在安全监控系统中，实时捕捉视频流中的人脸，并通过CNN进行特征提取和比对，识别出潜在的嫌疑人。</p>
<p>人脸对齐：</p>
<p>在进行人脸识别之前，使用深度学习算法（如Dlib库中的人脸对齐技术）对人脸进行标准化处理，以提高识别精度。</p>
<p>应用示例：在社交媒体平台中，用户上传的照片经过对齐处理后，系统能够更准确地进行自动标记。</p>
<p>生成对抗网络（GAN）：</p>
<p>使用GAN生成高质量的人脸图像，增强训练数据集，提升模型的鲁棒性。</p>
<p>应用示例：在面部表情识别中，通过生成多样化的表情图像，提升模型对不同情绪的识别能力。</p>
<h4 id="拍物检索"><a href="#拍物检索" class="headerlink" title="拍物检索"></a>拍物检索</h4><p>深度学习图像分类：</p>
<p>使用预训练的深度学习模型（如ResNet、Inception）进行物体识别。通过迁移学习，针对特定商品进行微调。</p>
<p>应用示例：用户拍摄商品，应用程序通过深度学习模型识别商品类别，并提供相关信息和购买链接。</p>
<p>特征匹配与检索：</p>
<p>利用深度学习提取图像特征向量，构建特征数据库，通过相似度计算实现快速检索。</p>
<p>应用示例：在博物馆中，游客拍摄展品，系统通过特征匹配快速提供展品的详细信息。</p>
<ol>
<li>图像分割：</li>
</ol>
<p>使用深度学习进行图像分割（如U-Net），提取物体的精确边界，提升识别的准确性。</p>
<p>应用示例：在植物识别应用中，通过分割技术提取植物的特征，帮助用户更准确地识别植物种类。</p>
<p>这些深度学习技术的结合，使得人脸识别和拍物检索的应用更加智能化和高效</p>
<h4 id="1-人脸识别"><a href="#1-人脸识别" class="headerlink" title="1. 人脸识别"></a>1. 人脸识别</h4><p>应用场景：</p>
<p>安全监控：</p>
<p>在公共场所（如机场、车站）部署摄像头，实时监控人群，识别可疑人员。</p>
<p>结合大数据分析，识别潜在的犯罪行为，提升公共安全。</p>
<p>身份验证：</p>
<p>在手机、电脑等设备上使用人脸识别进行解锁，替代传统密码。</p>
<p>在金融支付场景中，使用人脸识别进行身份验证，提升安全性。</p>
<p>技术实现：</p>
<p>卷积神经网络（CNN）：</p>
<p>模型选择：使用VGGFace、FaceNet或ArcFace等预训练模型，进行人脸特征提取。</p>
<p>特征提取：通过CNN提取128维或256维的特征向量，形成每个人脸的独特表示。</p>
<p>人脸对齐：</p>
<p>技术：使用Dlib库中的人脸关键点检测，确保人脸在同一标准姿态下进行识别。</p>
<p>步骤：检测人脸后，进行旋转和缩放，使得眼睛和嘴巴位置一致，减少姿态变化对识别的影响。</p>
<p>生成对抗网络（GAN）：</p>
<p>数据增强：使用GAN生成多样化的人脸图像，增加训练数据的多样性，提升模型的泛化能力。</p>
<p>应用：在训练过程中，生成不同表情、光照条件下的人脸图像，提升模型的鲁棒性。</p>
<p>性能优化：</p>
<p>实时处理：</p>
<p>硬件加速：使用GPU或TPU加速模型推理，确保在高帧率下处理视频流。</p>
<p>模型压缩：采用模型剪枝、量化和知识蒸馏等技术，减少模型大小，提高推理速度。</p>
<p>准确性提升：</p>
<p>数据增强：通过旋转、翻转、亮度调整、噪声添加等方式增强训练数据，提升模型的鲁棒性。</p>
<p>迁移学习：在特定领域（如安防）进行微调，提升模型在特定场景下的表现。</p>
<p>系统架构：</p>
<p>前端：摄像头采集视频流，进行人脸检测和识别。</p>
<p>后端：服务器接收视频流，进行特征提取和比对，返回识别结果。</p>
<p>数据库：存储人脸特征向量和用户信息，支持快速检索。</p>
<h4 id="2-拍物检索"><a href="#2-拍物检索" class="headerlink" title="2. 拍物检索"></a>2. 拍物检索</h4><p>应用场景：</p>
<p>购物应用：</p>
<p>用户拍摄商品，系统识别并提供购买链接、价格比较和用户评价。</p>
<p>结合AR技术，用户可以在现实环境中查看商品信息。</p>
<p>博物馆导览：</p>
<p>用户拍摄展品，系统提供详细信息、历史背景和相关视频。</p>
<p>结合语音识别，用户可以通过语音询问展品信息。</p>
<p>植物识别：</p>
<p>用户拍摄植物，系统识别植物种类并提供养护建议、生态信息。</p>
<p>技术实现：</p>
<p>深度学习图像分类：</p>
<p>模型选择：使用ResNet、Inception或EfficientNet进行物体识别。</p>
<p>训练数据：收集大量商品或展品的图像，进行标注和分类，确保数据的多样性和代表性。</p>
<p>特征匹配与检索：</p>
<p>特征提取：使用深度学习模型提取图像特征向量，构建特征数据库。</p>
<p>相似度计算：使用余弦相似度、欧氏距离或Hamming距离进行特征匹配，快速检索相似物体。</p>
<p>图像分割：</p>
<p>技术：使用U-Net或Mask R-CNN进行物体边界提取，确保物体特征的准确性。</p>
<p>应用：在植物识别中，通过分割提取植物的特征，帮助用户更准确地识别。</p>
<p>性能优化：</p>
<p>快速检索：</p>
<p>索引结构：使用KD树、LSH（局部敏感哈希）或Faiss等加速特征检索。</p>
<p>缓存机制：对常见查询结果进行缓存，提升响应速度，减少重复计算。</p>
<p>准确性提升：</p>
<p>多模态学习：结合图像和文本信息（如商品描述、用户评价）进行联合学习，提升识别准确性。</p>
<p>在线学习：根据用户反馈不断更新模型，提升系统的适应性和准确性。</p>
<p>系统架构：</p>
<p>前端：用户通过手机或平板拍摄图像，上传至服务器。</p>
<p>后端：服务器接收图像，进行特征提取、匹配和检索，返回识别结果和相关信息。</p>
<p>数据库：存储商品、展品或植物的图像特征向量和相关信息，支持快速检索。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>通过深度学习技术的综合应用，能够有效提升人脸识别和拍物检索的准确性和效率，满足实际应用中的需求。这种设计不仅考虑了技术实现，还注重了性能优化，确保系统在实际应用中的可行性和可靠性。通过不断迭代和优化，系统能够适应不断变化的环境和用户需求，提供更好的用户体验。</p>
<h3 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h3><h4 id="1-深度学习网络结构"><a href="#1-深度学习网络结构" class="headerlink" title="1. 深度学习网络结构"></a>1. 深度学习网络结构</h4><p>卷积神经网络（CNN）</p>
<p>应用示例：</p>
<p>图像分类：使用CNN对手写数字进行识别（如MNIST数据集）。</p>
<p>目标检测：使用YOLO（You Only Look Once）模型进行实时物体检测。</p>
<p>结构分析：</p>
<p>卷积层：通过卷积操作提取局部特征，使用多个卷积核提取不同特征。</p>
<p>池化层：通过最大池化或平均池化降低特征图的维度，减少计算量。</p>
<p>全连接层：将卷积层提取的特征映射到最终的分类结果。</p>
<p>循环神经网络（RNN）</p>
<p>应用示例：</p>
<p>自然语言处理：使用RNN进行文本生成（如生成诗歌或故事）。</p>
<p>时间序列预测：使用RNN预测股票价格变化。</p>
<p>结构分析：</p>
<p>输入层：接收序列数据（如单词、时间序列）。</p>
<p>隐藏层：通过循环连接处理序列信息，保持上下文信息。</p>
<p>输出层：生成预测结果（如下一个单词或时间点的值）。</p>
<p>生成对抗网络（GAN）</p>
<p>应用示例：</p>
<p>图像生成：使用GAN生成高质量的合成图像（如人脸图像）。</p>
<p>数据增强：通过生成新样本来扩充训练数据集。</p>
<p>结构分析：</p>
<p>生成器：生成假图像，试图欺骗判别器。</p>
<p>判别器：判断输入图像是真实的还是生成的。</p>
<p>对抗训练：生成器和判别器相互博弈，提升生成图像的质量。</p>
<h4 id="2-损失函数设计"><a href="#2-损失函数设计" class="headerlink" title="2. 损失函数设计"></a>2. 损失函数设计</h4><p>交叉熵损失</p>
<p>应用示例：</p>
<p>多类分类问题：在图像分类任务中，使用交叉熵损失来优化模型（如CIFAR-10数据集）。</p>
<p>分析：</p>
<p>定义：衡量预测概率分布与真实标签分布之间的差异。</p>
<p>优点：适用于多类分类问题，能够有效优化模型，尤其在类别不平衡时表现良好。</p>
<p>均方误差（MSE）</p>
<p>应用示例：</p>
<p>回归问题：在房价预测中，使用MSE来评估模型的预测效果。</p>
<p>分析：</p>
<p>定义：计算预测值与真实值之间的平方差的平均值。</p>
<p>优点：简单易用，适合线性回归模型，能够有效反映预测误差。</p>
<p>对比损失（Contrastive Loss）</p>
<p>应用示例：</p>
<p>人脸识别：在训练人脸识别模型时，使用对比损失来优化相似性和差异性。</p>
<p>分析：</p>
<p>定义：通过最小化相似样本之间的距离和最大化不相似样本之间的距离来训练模型。</p>
<p>优点：有效提升模型对相似性和差异性的学习能力，适合于无监督学习场景。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>通过对深度学习网络结构和损失函数的分析，可以深入理解模型的设计思路和优化目标。这些例子展示了不同网络结构和损失函数在实际应用中的重要性和适用性，帮助我们更好地选择合适的模型和损失函数以满足特定任务的需求。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>无奈、复杂与挣扎 --初读《曾国藩传》有感</title>
    <url>/%E6%97%A0%E5%A5%88%E3%80%81%E5%A4%8D%E6%9D%82%E4%B8%8E%E6%8C%A3%E6%89%8E.md/</url>
    <content><![CDATA[<p>有感而发，纯是记录<br><span id="more"></span><br>​    <p style="text-indent:2em">已经好久没有进入过心流了。之前被世俗的纷繁杂事烦身已久，加之自己邀功心切，在焦虑和自我麻痹中度过了小半年的光景。这小半年，可以说是一事无成。拖着疲惫的身躯回到家中，修养了近一月，未有太大好转。直到这传记的出现，才带来了一丝慰藉。似乎找到了一丝的安静。</p></p>
<p>​    <p style="text-indent:2em">伟人，何以为伟人也？“必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能”。此所谓天将降大任于斯人也。的确，曾祖就是这样一个担大任又颇具英雄色彩的一个人物。</p></p>
<p>​    <p style="text-indent:2em">从家族历代来看，他是最成功的。当然离不开先前祖先的各种铺路。其实从他的曾祖父元吉兄开始，家族就有了起势的苗头，直到他的爷爷曾玉屏（星冈公）的出现，才真正走向正轨。星冈公开始意识到读书的重要性，就具全家之力供其儿子曾麟书学习，但书未有天资，很认真的学习，但是一直都没有考出来。直到第17次考试，学政大人看不下去了，送了他一个县首，也就是知县，在换句话说也就是现在的县长，兄弟，这可是副处啊。人家爸爸是县长，而且还算是不会读书的，这我们怎么比啊。虽然他也考了很多次才中秀才，但是那时候也只有24岁，接着27岁又中了进士，算是非常快的了。虽然他的排名都不算靠前，但是凭借面试的精彩发挥，也是为自己博得了皇帝的认可。在八年间连升六级，从一个无名之辈直接干到二品大官，也是前无古人后无来者了。</p></p>
<p>​    <p style="text-indent:2em">但其实，他在这8年当中过的并不是非常的顺利。他也不想去参加各种宴请，他也有各种情绪，也经常和各种人对着干，但是他有人保着他。他的恩师穆彰阿一直在朝中护着他，让他免受了很多的是非。可以说，在他在京城当官的这不到40年的光景里，是他人生中较为稳定，较为自洽，较为舒适的一段时光。每个人的出场设定都不一样，但是他这前面这段路，走的确乎是有点顺的。</p></p>
<p>​    <p style="text-indent:2em">接下来才是他人生中最为具有故事性的阶段。因讨伐太平军，他成立了湘军。这才是他人格体现的最为淋漓尽致的时光。他心中所有的无奈，复杂，挣扎以及痛苦，全在这段时间中显现出来，而且异常生动。</p></p>
<p>​    <p style="text-indent:2em">湘军从最开始的一无所有到后来的发展壮大，每一步都离不开他的苦心经营。一介书生，创立军队，这听起来有点荒谬，但在那个年代，那个如此动荡，内忧外患，战事连篇的时代，确实需要这样一个优秀的地方军来实现与太平军的对抗。因为他是封建王朝的既得利益者，他其实也想维护清政府的统治，所以很多时候，虽然他身为湘军首领，湘军的开山鼻祖，他很多时候不得不听令于朝廷。堂堂二品大官，不在京城，却在湖南两广地区创建军队。他的本意是要镇压太平起义，在他的领导之下，“以礼治军”，“从严治军”，让湘军成为了当时唯一一支能与地方起义军抗衡的军队，但同时，由于过于强大的势力，也让朝廷产生了担忧。各自都非常清楚，朝廷想的什么，曾想的什么。曾就是在这样的背景之下，创办了闻名历史的湘军。英勇善战，训练有素，有条不紊应该能够很好的概括湘军了。</p></p>
<p>​    <p style="text-indent:2em">他的无奈与复杂，体现在很多方面。作为朝中要臣，他渴望振兴清朝，振兴国家。但作为父母的孩子，作为最大的兄长，作为一个孩子的父亲，他又希望自己的家庭能够幸福美满。作为湘军首领，他渴望早日扫清障碍，留下功名。作为师长，他渴望自己的学生李鸿章等人能够发展壮大。作为一个优秀的朋友，他渴望和自己有共同抱负的同志一起实现一番伟业。</p></p>
<p>​    <p style="text-indent:2em">但现实总是在开玩笑。</p></p>
<p>​    <p style="text-indent:2em">父母过世，只有父亲过世时回家丁忧，没能见到父母最后一面。虽然没有记载，但我觉得，作为一个中华儿女，“子欲养而亲不在”是这世间最悲伤的结局。哪怕是回家戴孝，也多次因为战事夺情出山。他三弟，各大湘军重要领袖，很多都于与太平军对峙时战死。这其中有很多是他的左膀右臂，都和他们交情颇深。特别是三弟的死，让他更加难以接受。那可是他亲弟啊。以家国大义为重，这很伟大，但是我做不到。我只希望能够有一个快乐的生活。    </p></p>
<p>​    <p style="text-indent:2em">清王朝的统治，在那个时代，已经是病入膏肓，无可救药了。同时期的西方各国已经开始了工业革命，先进的科技生产力，先进的文化，先进的设备都是当时的中国所不能匹及的。他也在寻求改变。虽然最开始是反对林则徐的保守派，但后来，直到国内局势相对稳定之时，内忧相对较少时，他就已经意识到，“师夷长技以制夷”。只有这样，才有可能挽留它的统治。事实是，他引领了一波潮流，史称“洋务运动”。只不过他看不到那段由他的思想缔造的盛世了。</p></p>
<p>​    <p style="text-indent:2em">创建湘军，既是历史必然，也是实属无奈。一个读书人，我没事干嘛搞军队啊，搞完了上面的人还要搞我，下面的也不一定听话，也很少有人支持我，我图啥呢？我觉得，曾的回答会是：为了家国安定。宏大的胸怀，超越历史的眼界，跨越现象的大局观，都让他成为了湘军不可替代的唯一首领。在这其中，他也多次想要自杀，一了百了。海战的时候，投江准备结束生命，被人救起。那时候的他，除了绝望，心中应该没有第二个感受了吧。 虽没有记载，我觉得他应该在想，他是多么的无能，是多么的自责。这倾尽他几乎所有心血的湘军海军，在那一战中几乎都化成虚无。这是无人能够体会的。那种痛楚，只有经历过，才会懂。</p></p>
<p>​    <p style="text-indent:2em">他的挣扎在于，他其实在用一生治愈他那不安的内心。他其实不愿做官，不愿打仗，不愿大富，他只求平平安安，做好每一件事。但是局势不允许，或者说，即使他再怎么不愿意，他天生就是要来干大事的。从连升六级开始，他就开始了和他不安的内心斗争。他一生都在努力成为那个更好的自己，为的是不被辜负期待。可能也只有他自己才知道自己身上究竟肩负着什么吧。</p></p>
<p>​    <p style="text-indent:2em">他是幸运的。每次在他迷茫之际，在他在京官走投无路之际，都有一个贵人出手相救。不能说他是纯粹依靠贵人，但是没有贵人的话，他是不可能能有这样的成就的。当然，这和他进入实现范围是有关系的。如果他没有通过进士的考试，也就不会有后续这一系列历史典故了。他父亲考了17次才考上的秀才，从年少考到中年，而他，年仅27便达到了他父亲一辈子都打不打的高度，更不用说后续的二品官和湘军了。</p></p>
<p>​    <p style="text-indent:2em">本来是想记录一下他是怎么度过困难的，但是好像记载的不多。他也会因为对世界失去信心而选择跳江自杀，这让我感受到，他也是一个活生生的人。也有较大的情绪波动，也会有想不开的时候。可能只有最接近生死的那一瞬间，才能激发出前所未有的能量吧。</p></p>
<p>​    <p style="text-indent:2em">洋洋洒洒写了2k多字，就当是自娱自乐吧。</p></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>春</title>
    <url>/%E6%98%A5.md/</url>
    <content><![CDATA[<p>仅仅是一些记录。不足挂齿<br><span id="more"></span></p>
<h1 id="春"><a href="#春" class="headerlink" title="春"></a><p style="text-align:center">春</p></h1><h2 id="玉渊潭游感"><a href="#玉渊潭游感" class="headerlink" title="玉渊潭游感"></a><p style="text-align:center">玉渊潭游感</p></h2><p style="text-align:center">华灯初上，灯火通明。</p>
<p style="text-align:center">众叛亲离，泣不成声。</p>
<p style="text-align:center">独坐亭中，暗自神伤。</p>
<p style="text-align:center">不绝如缕，辗转反侧。</p>
<p style="text-align:center">晨光熹微，遂外探春。</p>
<p style="text-align:center">友未空闲，独自前往。</p>
<p style="text-align:center">桃月之名，众望所归。</p>
<p style="text-align:center">春和景明，波澜不惊。</p>
<p style="text-align:center">翠树柔藤，交缀葱茏。</p>
<p style="text-align:center">碎花圆蕊，交相辉映。</p>
<p style="text-align:center">含苞待放，相映成趣。</p>
<p style="text-align:center">水光潋滟，微风习习。</p>
<p style="text-align:center">仰观宇宙，俯察品类。</p>
<p style="text-align:center">广阔湖面，桃李春风。</p>
<p style="text-align:center">淡然释怀，贻笑万物。</p>
<p style="text-align:center">花香满楼，已是万幸。</p>
<p style="text-align:center">世事苦短，人情云薄。</p>
<p style="text-align:center">无需计较，万事有命。</p>
<p style="text-align:center">天涯之盛，何处无芳！</p>
<p style="text-align:center">以往不谏，来者可追。</p>
<p style="text-align:center"> </p>



<p style="text-align:center">华灯初上，灯火通明。</p>
<p style="text-align:center">好友已至，遂食烟火。</p>
<p style="text-align:center">欢声笑语，宠辱偕忘。</p>
<p style="text-align:center">夜深人静，街头闲肆。</p>
<p style="text-align:center">谈天说地，回首过往。</p>
<p style="text-align:center">凉水代酒，畅所欲言。</p>
<p style="text-align:center">春风送别，挥挥衣袖。</p>
<p style="text-align:center">仰笑出门，岂为蓬篙？</p>
<p style="text-align:center">光影摇曳，朦胧入梦。</p>


<p><p style="text-align:center"> </p><br>附一些照片，均于玉渊潭拍摄<br><img src="/%E6%98%A5.md/1.png" class="" title="img"><br><img src="/%E6%98%A5.md/2.png" class="" title="img"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>香农熵，交叉熵和KL散度</title>
    <url>/%E9%A6%99%E5%86%9C%E7%86%B5%EF%BC%8C%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8CKL%E6%95%A3%E5%BA%A6.md/</url>
    <content><![CDATA[<p>diffusion model涉及的东西太多了，补知识ing<br><span id="more"></span><br>饮水思源：<a href="https://www.bilibili.com/video/BV1JY411q72n/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db8b493990184e57185c5ce1734577f2">【10分钟】了解香农熵，交叉熵和KL散度_哔哩哔哩_bilibili</a></p>
<h2 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h2><p>是一个人为定义</p>
<p>一般认为：</p>
<p>事件的概率越大，信息量越少</p>
<p>事件的概率越小，信息量越大</p>
<p>我们定义事件的概率为<script type="math/tex">p(x)</script>,则信息量为<script type="math/tex">I(x)=log_2(\frac{1}{p(x)})=-log_2(p(x))</script>.</p>
<p>符合前面的定义<br><br></p>
<h2 id="香农熵"><a href="#香农熵" class="headerlink" title="香农熵"></a>香农熵</h2><p>一个概率分布的平均信息量，通常也是不确定性(uncertainty)度量的标准</p>
<p>公式定义为<script type="math/tex">H(x)=\sum{p_i I^p_i}=\sum{p_i log_2(\frac{1}{p_i})}</script></p>
<p>以硬币为例子</p>
<p>假设正反的概率<script type="math/tex">p(h)=p(t)=0.5</script></p>
<p>则<script type="math/tex">H(p)=p(h) \times log_2(\frac{1}{p(h)})+p(t) \times log_2(\frac{1}{p(t)})=0.5 \times 1+ 0.5\times 1 = 1</script></p>
<p>假设正面的概率<script type="math/tex">q(h)=0.2</script>，反面的概率为<script type="math/tex">q(t)=0.8</script></p>
<p>则<script type="math/tex">H(q)=q(h) \times log_2(\frac{1}{q(h)}) + q(t) \times log_2(\frac{1}{q(t)}) = 0.2 \times log_25+0.8 \times (log_25-2) = log_25 - 1.6 = 0.72</script></p>
<p>对于一个确定的概率密度函数(p)</p>
<p>如果它越均匀，也就是如果它各种情况出现的概率越平均，说明越不确定，熵越大（当硬币正反都是0.5时，香农熵为1）</p>
<p>如果它越集中，也就是如果它各种情况出现的概率差距越大，说明越确定（有某一个出现的概率很大），熵越小</p>
<p><br></p>
<h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>这个比较有意思</p>
<p>它计算的是预测出来的GT（ground truth）概率分布的平均信息熵。（确实挺绕的）</p>
<p>按照视频里的英文是，given estimated probability distribution, the estimation of expected amount of information of ground truth probability distribution. </p>
<p>因为涉及到两个部分，一个真实的概率一个预测出来的概率，所以称为交叉熵。</p>
<p>//当作没有这行……我们假设GT是<script type="math/tex">p(h)=p(t)=0.5</script>，预测出来的<script type="math/tex">q(h)=0.2,q(t)=0.8</script></p>
<p>交叉熵的公式为<script type="math/tex">H(p,q)= \sum{p_iI_i^q}= \sum{p_ilog_2{\frac{1}{q_i}}} = -\sum {p_ilog_2q_i}</script></p>
<p><strong>可以理解成用真实的概率<script type="math/tex">\mathbf{p_i}</script>作为预测出来的概率<script type="math/tex">\mathbf{q_i}</script>的信息量的权重，进行加权求和</strong></p>
<p>（不想写例子了，这个latex公式敲的好累，具体例子看视频吧）</p>
<p>当预测出来的概率越接近真实值时，交叉熵的值越接近于真实的熵值。（这里的熵指的是香农熵）</p>
<p><br></p>
<h2 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h2><p>来了兄弟们</p>
<p>单说公式，特别简单，<strong>就是两个分布之间的交叉熵减去其中一个的熵</strong>。用于衡量两个分布之间的差距</p>
<p>公式为</p>
<script type="math/tex; mode=display">
D(p||q) = H(p,q) - H(p) = \sum{p_iI^q_i} - \sum{p_iI_i^p} = \sum{p_ilog_2{\frac{1}{q_i}}} - \sum{p_ilog_2{\frac{1}{p_i}}} = \sum{p_ilog_2{p_i}} - \sum{p_ilog_2{q_i}} = \sum{p_ilog_2{\frac{p_i}{q_i}}}</script><p>有俩重要的性质（至于这俩性质的推导我就没管了，感觉知道就行）</p>
<p>1、非负性 <script type="math/tex">D(p||q)\geq 0</script> 当且仅当两个分布完全一样时会等于0</p>
<p>2、非对称性 <script type="math/tex">D(p||q) \neq D(q||p)</script>，<strong>说明该指标衡量的不是距离</strong><br><br></p>
<p>在机器学习中，最小化KL散度有时候等价于最小化交叉熵</p>
<p>从梯度（求导）的角度来看 <script type="math/tex">\nabla_{\theta}D(p||q_{\theta}) = \nabla_{\theta}H(p,q)-\nabla_{\theta}H(p) = \nabla_{\theta}H(p,q)</script></p>
<p><br></p>
<p>KL的另一种推导方法，更加直观，感觉这就写的挺好的，我就不再手打了</p>
<img src="/%E9%A6%99%E5%86%9C%E7%86%B5%EF%BC%8C%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8CKL%E6%95%A3%E5%BA%A6.md/1.png" class="" title="img">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上公式最直接了,<script type="math/tex">p_i</script>是某事件的概率</p>
<p>信息量：<script type="math/tex">I(x)=log_2(\frac{1}{p(x)})=-log_2(p(x))</script>.</p>
<p>香农熵：<script type="math/tex">H(x)=\sum{p_i I^p_i}=\sum{p_i log_2(\frac{1}{p_i})}</script></p>
<p>交叉熵：<script type="math/tex">H(p,q)= \sum{p_iI_i^q}= \sum{p_ilog_2{\frac{1}{q_i}}} = -\sum {p_ilog_2q_i}</script></p>
<p>KL散度：</p>
<script type="math/tex; mode=display">
D(p||q) = H(p,q) - H(p) = \sum{p_iI^q_i} - \sum{p_iI_i^p} = \sum{p_ilog_2{\frac{1}{q_i}}} - \sum{p_ilog_2{\frac{1}{p_i}}} = \sum{p_ilog_2{p_i}} - \sum{p_ilog_2{q_i}} = \sum{p_ilog_2{\frac{p_i}{q_i}}}</script><p>终于能接着学后面的了，东西真多</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
